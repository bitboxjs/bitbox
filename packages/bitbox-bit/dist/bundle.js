(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("bit", [], factory);
	else if(typeof exports === 'object')
		exports["bit"] = factory();
	else
		root["bit"] = factory();
})(this, function() {
return webpackJsonpbit([1],[
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _bit = __webpack_require__(1);\n\nvar _bit2 = _interopRequireDefault(_bit);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _bit2.default;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./index.js\n ** module id = 0\n ** module chunks = 1\n **/\n//# sourceURL=webpack:///./index.js?");

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _keys = __webpack_require__(2);\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _extends2 = __webpack_require__(37);\n\nvar _extends3 = _interopRequireDefault(_extends2);\n\nvar _map = __webpack_require__(44);\n\nvar _map2 = _interopRequireDefault(_map);\n\nexports.default = bit;\n\nvar _cerebral = __webpack_require__(83);\n\nvar _cerebralModelImmutable = __webpack_require__(147);\n\nvar _cerebralModelImmutable2 = _interopRequireDefault(_cerebralModelImmutable);\n\nvar _cerebralModel = __webpack_require__(156);\n\nvar _cerebralModel2 = _interopRequireDefault(_cerebralModel);\n\nvar _cerebralProviderModules = __webpack_require__(161);\n\nvar _cerebralProviderModules2 = _interopRequireDefault(_cerebralProviderModules);\n\nvar _cerebralModuleDevtools = __webpack_require__(162);\n\nvar _cerebralModuleDevtools2 = _interopRequireDefault(_cerebralModuleDevtools);\n\nvar _getState = __webpack_require__(173);\n\nvar _getState2 = _interopRequireDefault(_getState);\n\nvar _getSignals = __webpack_require__(174);\n\nvar _getSignals2 = _interopRequireDefault(_getSignals);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar defaultOptions = {\n\tenv: 'dev',\n\timmutable: true\n};\n\nbit.index = 0;\nbit.map = new _map2.default();\n\nfunction bit() {\n\tvar state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\tvar modules = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\tvar options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n\n\tbit.index++;\n\tvar config = (0, _extends3.default)({}, defaultOptions, options);\n\n\tvar model = config.immutable ? (0, _cerebralModelImmutable2.default)(state) : (0, _cerebralModel2.default)(state);\n\n\tvar controller = (0, _cerebral.Controller)(model);\n\n\tcontroller.addModules(modules);\n\n\tif (config.env === 'dev') controller.addModules({ devtools: (0, _cerebralModuleDevtools2.default)() });\n\n\tcontroller.addSignals({\n\t\tstateChanged: [function setState(_ref) {\n\t\t\tvar input = _ref.input;\n\t\t\tvar state = _ref.state;\n\n\t\t\tstate.set(input.path, input.value);\n\t\t}]\n\t});\n\n\tcontroller.addContextProvider(_cerebralProviderModules2.default);\n\n\tvar app = {\n\t\t__proto__: {\n\t\t\t'[bitbox]': true,\n\t\t\tconnections: null,\n\t\t\tpaths: null\n\t\t},\n\t\tlisten: function listen(path, fn) {\n\t\t\tif (!app.paths) {\n\t\t\t\tapp.paths = {};\n\t\t\t\tcontroller.on('changed', function (e) {\n\t\t\t\t\t(0, _keys2.default)(e.bitmap).forEach(function (path) {\n\t\t\t\t\t\tif (app.paths[path] && app.paths[path].listener) {\n\t\t\t\t\t\t\tapp.paths[path].listener({\n\t\t\t\t\t\t\t\tpath: path,\n\t\t\t\t\t\t\t\tcount: ++app.paths[path].count,\n\t\t\t\t\t\t\t\tindex: e.bitmap[path],\n\t\t\t\t\t\t\t\trendered: e.rendered,\n\t\t\t\t\t\t\t\tduration: e.duration\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (!app.paths[path]) app.paths[path] = {\n\t\t\t\t\t\t\t\tcount: 0\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tapp.paths[path].count++;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (!app.paths[path]) {\n\t\t\t\tapp.paths[path] = {\n\t\t\t\t\tlistener: fn,\n\t\t\t\t\tcount: 0,\n\t\t\t\t\tstop: function stop() {\n\t\t\t\t\t\treturn delete app.paths[path].listener;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tapp.paths[path].listener = fn;\n\t\t\t}\n\t\t\treturn app.paths[path];\n\t\t},\n\t\tadd: function add(type, value) {\n\t\t\tvar types = {\n\t\t\t\tcontextProvider: 'addContextProvider',\n\t\t\t\tlistener: 'addListener',\n\t\t\t\tmodules: 'addModules',\n\t\t\t\tsignals: 'addSignals',\n\t\t\t\tservices: 'addServices'\n\t\t\t};\n\t\t\tvar key = '' + (type[0].toUpperCase() + type.substring(1));\n\n\t\t\tif (!(type in types)) throw new Error('Invalid type: ' + type + ', expected: ' + (0, _keys2.default)(types));\n\n\t\t\tcontroller[types[type]](value);\n\t\t\treturn controller['get' + types[type].substr(3)]();\n\t\t},\n\t\ton: function on() {\n\t\t\tcontroller.on.apply(controller, arguments);\n\t\t\treturn controller._events;\n\t\t},\n\t\tonce: function once() {\n\t\t\tcontroller.once.apply(controller, arguments);\n\t\t\treturn controller._events;\n\t\t},\n\t\toff: function off(type, fn) {\n\t\t\tif (fn) controller.removeListener(type, fn);else controller.removeAllListeners.apply(controller, arguments);\n\t\t\treturn controller._events;\n\t\t},\n\n\t\tget config() {\n\t\t\treturn config;\n\t\t},\n\t\tget model() {\n\t\t\treturn controller.getModel();\n\t\t},\n\t\tget controller() {\n\t\t\treturn controller;\n\t\t},\n\t\tcompute: function compute() {\n\t\t\treturn _cerebral.Computed.apply(undefined, arguments);\n\t\t},\n\t\tstate: function state(input) {\n\t\t\treturn (0, _getState2.default)(input, controller);\n\t\t},\n\t\tsignals: function signals(input) {\n\t\t\treturn (0, _getSignals2.default)(input, controller);\n\t\t},\n\t\tservices: function services(input) {\n\t\t\treturn controller.getServices(input);\n\t\t},\n\t\tmodules: function modules(input) {\n\t\t\treturn controller.getModules(input);\n\t\t}\n\t};\n\n\treturn app;\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/src/bit/index.js\n ** module id = 1\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/src/bit/index.js?");

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports = { \"default\": __webpack_require__(3), __esModule: true };\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/babel-runtime/core-js/object/keys.js\n ** module id = 2\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/babel-runtime/core-js/object/keys.js?");

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(4);\nmodule.exports = __webpack_require__(24).Object.keys;\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/fn/object/keys.js\n ** module id = 3\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/fn/object/keys.js?");

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	eval("// 19.1.2.14 Object.keys(O)\nvar toObject = __webpack_require__(5)\n  , $keys    = __webpack_require__(7);\n\n__webpack_require__(22)('keys', function(){\n  return function keys(it){\n    return $keys(toObject(it));\n  };\n});\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/es6.object.keys.js\n ** module id = 4\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/es6.object.keys.js?");

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	eval("// 7.1.13 ToObject(argument)\nvar defined = __webpack_require__(6);\nmodule.exports = function(it){\n  return Object(defined(it));\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_to-object.js\n ** module id = 5\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_to-object.js?");

/***/ },
/* 6 */
/***/ function(module, exports) {

	eval("// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function(it){\n  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_defined.js\n ** module id = 6\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_defined.js?");

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	eval("// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys       = __webpack_require__(8)\n  , enumBugKeys = __webpack_require__(21);\n\nmodule.exports = Object.keys || function keys(O){\n  return $keys(O, enumBugKeys);\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_object-keys.js\n ** module id = 7\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_object-keys.js?");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	eval("var has          = __webpack_require__(9)\n  , toIObject    = __webpack_require__(10)\n  , arrayIndexOf = __webpack_require__(13)(false)\n  , IE_PROTO     = __webpack_require__(17)('IE_PROTO');\n\nmodule.exports = function(object, names){\n  var O      = toIObject(object)\n    , i      = 0\n    , result = []\n    , key;\n  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while(names.length > i)if(has(O, key = names[i++])){\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_object-keys-internal.js\n ** module id = 8\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_object-keys-internal.js?");

/***/ },
/* 9 */
/***/ function(module, exports) {

	eval("var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function(it, key){\n  return hasOwnProperty.call(it, key);\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_has.js\n ** module id = 9\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_has.js?");

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	eval("// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = __webpack_require__(11)\n  , defined = __webpack_require__(6);\nmodule.exports = function(it){\n  return IObject(defined(it));\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_to-iobject.js\n ** module id = 10\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_to-iobject.js?");

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	eval("// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = __webpack_require__(12);\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_iobject.js\n ** module id = 11\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_iobject.js?");

/***/ },
/* 12 */
/***/ function(module, exports) {

	eval("var toString = {}.toString;\n\nmodule.exports = function(it){\n  return toString.call(it).slice(8, -1);\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_cof.js\n ** module id = 12\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_cof.js?");

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	eval("// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = __webpack_require__(10)\n  , toLength  = __webpack_require__(14)\n  , toIndex   = __webpack_require__(16);\nmodule.exports = function(IS_INCLUDES){\n  return function($this, el, fromIndex){\n    var O      = toIObject($this)\n      , length = toLength(O.length)\n      , index  = toIndex(fromIndex, length)\n      , value;\n    // Array#includes uses SameValueZero equality algorithm\n    if(IS_INCLUDES && el != el)while(length > index){\n      value = O[index++];\n      if(value != value)return true;\n    // Array#toIndex ignores holes, Array#includes - not\n    } else for(;length > index; index++)if(IS_INCLUDES || index in O){\n      if(O[index] === el)return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_array-includes.js\n ** module id = 13\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_array-includes.js?");

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	eval("// 7.1.15 ToLength\nvar toInteger = __webpack_require__(15)\n  , min       = Math.min;\nmodule.exports = function(it){\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_to-length.js\n ** module id = 14\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_to-length.js?");

/***/ },
/* 15 */
/***/ function(module, exports) {

	eval("// 7.1.4 ToInteger\nvar ceil  = Math.ceil\n  , floor = Math.floor;\nmodule.exports = function(it){\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_to-integer.js\n ** module id = 15\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_to-integer.js?");

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	eval("var toInteger = __webpack_require__(15)\n  , max       = Math.max\n  , min       = Math.min;\nmodule.exports = function(index, length){\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_to-index.js\n ** module id = 16\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_to-index.js?");

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	eval("var shared = __webpack_require__(18)('keys')\n  , uid    = __webpack_require__(20);\nmodule.exports = function(key){\n  return shared[key] || (shared[key] = uid(key));\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_shared-key.js\n ** module id = 17\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_shared-key.js?");

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	eval("var global = __webpack_require__(19)\n  , SHARED = '__core-js_shared__'\n  , store  = global[SHARED] || (global[SHARED] = {});\nmodule.exports = function(key){\n  return store[key] || (store[key] = {});\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_shared.js\n ** module id = 18\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_shared.js?");

/***/ },
/* 19 */
/***/ function(module, exports) {

	eval("// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\nif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_global.js\n ** module id = 19\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_global.js?");

/***/ },
/* 20 */
/***/ function(module, exports) {

	eval("var id = 0\n  , px = Math.random();\nmodule.exports = function(key){\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_uid.js\n ** module id = 20\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_uid.js?");

/***/ },
/* 21 */
/***/ function(module, exports) {

	eval("// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_enum-bug-keys.js\n ** module id = 21\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_enum-bug-keys.js?");

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	eval("// most Object methods by ES6 should accept primitives\nvar $export = __webpack_require__(23)\n  , core    = __webpack_require__(24)\n  , fails   = __webpack_require__(33);\nmodule.exports = function(KEY, exec){\n  var fn  = (core.Object || {})[KEY] || Object[KEY]\n    , exp = {};\n  exp[KEY] = exec(fn);\n  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_object-sap.js\n ** module id = 22\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_object-sap.js?");

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	eval("var global    = __webpack_require__(19)\n  , core      = __webpack_require__(24)\n  , ctx       = __webpack_require__(25)\n  , hide      = __webpack_require__(27)\n  , PROTOTYPE = 'prototype';\n\nvar $export = function(type, name, source){\n  var IS_FORCED = type & $export.F\n    , IS_GLOBAL = type & $export.G\n    , IS_STATIC = type & $export.S\n    , IS_PROTO  = type & $export.P\n    , IS_BIND   = type & $export.B\n    , IS_WRAP   = type & $export.W\n    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n    , expProto  = exports[PROTOTYPE]\n    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]\n    , key, own, out;\n  if(IS_GLOBAL)source = name;\n  for(key in source){\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    if(own && key in exports)continue;\n    // export native or passed\n    out = own ? target[key] : source[key];\n    // prevent global pollution for namespaces\n    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n    // bind timers to global for call from export context\n    : IS_BIND && own ? ctx(out, global)\n    // wrap global constructors for prevent change them in library\n    : IS_WRAP && target[key] == out ? (function(C){\n      var F = function(a, b, c){\n        if(this instanceof C){\n          switch(arguments.length){\n            case 0: return new C;\n            case 1: return new C(a);\n            case 2: return new C(a, b);\n          } return new C(a, b, c);\n        } return C.apply(this, arguments);\n      };\n      F[PROTOTYPE] = C[PROTOTYPE];\n      return F;\n    // make static versions for prototype methods\n    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n    if(IS_PROTO){\n      (exports.virtual || (exports.virtual = {}))[key] = out;\n      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);\n    }\n  }\n};\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library` \nmodule.exports = $export;\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_export.js\n ** module id = 23\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_export.js?");

/***/ },
/* 24 */
/***/ function(module, exports) {

	eval("var core = module.exports = {version: '2.4.0'};\nif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_core.js\n ** module id = 24\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_core.js?");

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	eval("// optional / simple context binding\nvar aFunction = __webpack_require__(26);\nmodule.exports = function(fn, that, length){\n  aFunction(fn);\n  if(that === undefined)return fn;\n  switch(length){\n    case 1: return function(a){\n      return fn.call(that, a);\n    };\n    case 2: return function(a, b){\n      return fn.call(that, a, b);\n    };\n    case 3: return function(a, b, c){\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function(/* ...args */){\n    return fn.apply(that, arguments);\n  };\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_ctx.js\n ** module id = 25\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_ctx.js?");

/***/ },
/* 26 */
/***/ function(module, exports) {

	eval("module.exports = function(it){\n  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n  return it;\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_a-function.js\n ** module id = 26\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_a-function.js?");

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	eval("var dP         = __webpack_require__(28)\n  , createDesc = __webpack_require__(36);\nmodule.exports = __webpack_require__(32) ? function(object, key, value){\n  return dP.f(object, key, createDesc(1, value));\n} : function(object, key, value){\n  object[key] = value;\n  return object;\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_hide.js\n ** module id = 27\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_hide.js?");

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	eval("var anObject       = __webpack_require__(29)\n  , IE8_DOM_DEFINE = __webpack_require__(31)\n  , toPrimitive    = __webpack_require__(35)\n  , dP             = Object.defineProperty;\n\nexports.f = __webpack_require__(32) ? Object.defineProperty : function defineProperty(O, P, Attributes){\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if(IE8_DOM_DEFINE)try {\n    return dP(O, P, Attributes);\n  } catch(e){ /* empty */ }\n  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');\n  if('value' in Attributes)O[P] = Attributes.value;\n  return O;\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_object-dp.js\n ** module id = 28\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_object-dp.js?");

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	eval("var isObject = __webpack_require__(30);\nmodule.exports = function(it){\n  if(!isObject(it))throw TypeError(it + ' is not an object!');\n  return it;\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_an-object.js\n ** module id = 29\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_an-object.js?");

/***/ },
/* 30 */
/***/ function(module, exports) {

	eval("module.exports = function(it){\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_is-object.js\n ** module id = 30\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_is-object.js?");

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports = !__webpack_require__(32) && !__webpack_require__(33)(function(){\n  return Object.defineProperty(__webpack_require__(34)('div'), 'a', {get: function(){ return 7; }}).a != 7;\n});\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_ie8-dom-define.js\n ** module id = 31\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_ie8-dom-define.js?");

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	eval("// Thank's IE8 for his funny defineProperty\nmodule.exports = !__webpack_require__(33)(function(){\n  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n});\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_descriptors.js\n ** module id = 32\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_descriptors.js?");

/***/ },
/* 33 */
/***/ function(module, exports) {

	eval("module.exports = function(exec){\n  try {\n    return !!exec();\n  } catch(e){\n    return true;\n  }\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_fails.js\n ** module id = 33\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_fails.js?");

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	eval("var isObject = __webpack_require__(30)\n  , document = __webpack_require__(19).document\n  // in old IE typeof document.createElement is 'object'\n  , is = isObject(document) && isObject(document.createElement);\nmodule.exports = function(it){\n  return is ? document.createElement(it) : {};\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_dom-create.js\n ** module id = 34\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_dom-create.js?");

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	eval("// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = __webpack_require__(30);\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function(it, S){\n  if(!isObject(it))return it;\n  var fn, val;\n  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;\n  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_to-primitive.js\n ** module id = 35\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_to-primitive.js?");

/***/ },
/* 36 */
/***/ function(module, exports) {

	eval("module.exports = function(bitmap, value){\n  return {\n    enumerable  : !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable    : !(bitmap & 4),\n    value       : value\n  };\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_property-desc.js\n ** module id = 36\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_property-desc.js?");

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nexports.__esModule = true;\n\nvar _assign = __webpack_require__(38);\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _assign2.default || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/babel-runtime/helpers/extends.js\n ** module id = 37\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/babel-runtime/helpers/extends.js?");

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports = { \"default\": __webpack_require__(39), __esModule: true };\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/babel-runtime/core-js/object/assign.js\n ** module id = 38\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/babel-runtime/core-js/object/assign.js?");

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(40);\nmodule.exports = __webpack_require__(24).Object.assign;\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/fn/object/assign.js\n ** module id = 39\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/fn/object/assign.js?");

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	eval("// 19.1.3.1 Object.assign(target, source)\nvar $export = __webpack_require__(23);\n\n$export($export.S + $export.F, 'Object', {assign: __webpack_require__(41)});\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/es6.object.assign.js\n ** module id = 40\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/es6.object.assign.js?");

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n// 19.1.2.1 Object.assign(target, source, ...)\nvar getKeys  = __webpack_require__(7)\n  , gOPS     = __webpack_require__(42)\n  , pIE      = __webpack_require__(43)\n  , toObject = __webpack_require__(5)\n  , IObject  = __webpack_require__(11)\n  , $assign  = Object.assign;\n\n// should work with symbols and should have deterministic property order (V8 bug)\nmodule.exports = !$assign || __webpack_require__(33)(function(){\n  var A = {}\n    , B = {}\n    , S = Symbol()\n    , K = 'abcdefghijklmnopqrst';\n  A[S] = 7;\n  K.split('').forEach(function(k){ B[k] = k; });\n  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;\n}) ? function assign(target, source){ // eslint-disable-line no-unused-vars\n  var T     = toObject(target)\n    , aLen  = arguments.length\n    , index = 1\n    , getSymbols = gOPS.f\n    , isEnum     = pIE.f;\n  while(aLen > index){\n    var S      = IObject(arguments[index++])\n      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)\n      , length = keys.length\n      , j      = 0\n      , key;\n    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];\n  } return T;\n} : $assign;\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_object-assign.js\n ** module id = 41\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_object-assign.js?");

/***/ },
/* 42 */
/***/ function(module, exports) {

	eval("exports.f = Object.getOwnPropertySymbols;\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_object-gops.js\n ** module id = 42\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_object-gops.js?");

/***/ },
/* 43 */
/***/ function(module, exports) {

	eval("exports.f = {}.propertyIsEnumerable;\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_object-pie.js\n ** module id = 43\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_object-pie.js?");

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports = { \"default\": __webpack_require__(45), __esModule: true };\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/babel-runtime/core-js/map.js\n ** module id = 44\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/babel-runtime/core-js/map.js?");

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(46);\n__webpack_require__(47);\n__webpack_require__(60);\n__webpack_require__(64);\n__webpack_require__(80);\nmodule.exports = __webpack_require__(24).Map;\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/fn/map.js\n ** module id = 45\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/fn/map.js?");

/***/ },
/* 46 */
/***/ function(module, exports) {

	eval("\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/es6.object.to-string.js\n ** module id = 46\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/es6.object.to-string.js?");

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar $at  = __webpack_require__(48)(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\n__webpack_require__(49)(String, 'String', function(iterated){\n  this._t = String(iterated); // target\n  this._i = 0;                // next index\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , index = this._i\n    , point;\n  if(index >= O.length)return {value: undefined, done: true};\n  point = $at(O, index);\n  this._i += point.length;\n  return {value: point, done: false};\n});\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/es6.string.iterator.js\n ** module id = 47\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/es6.string.iterator.js?");

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	eval("var toInteger = __webpack_require__(15)\n  , defined   = __webpack_require__(6);\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function(TO_STRING){\n  return function(that, pos){\n    var s = String(defined(that))\n      , i = toInteger(pos)\n      , l = s.length\n      , a, b;\n    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_string-at.js\n ** module id = 48\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_string-at.js?");

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar LIBRARY        = __webpack_require__(50)\n  , $export        = __webpack_require__(23)\n  , redefine       = __webpack_require__(51)\n  , hide           = __webpack_require__(27)\n  , has            = __webpack_require__(9)\n  , Iterators      = __webpack_require__(52)\n  , $iterCreate    = __webpack_require__(53)\n  , setToStringTag = __webpack_require__(57)\n  , getPrototypeOf = __webpack_require__(59)\n  , ITERATOR       = __webpack_require__(58)('iterator')\n  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`\n  , FF_ITERATOR    = '@@iterator'\n  , KEYS           = 'keys'\n  , VALUES         = 'values';\n\nvar returnThis = function(){ return this; };\n\nmodule.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function(kind){\n    if(!BUGGY && kind in proto)return proto[kind];\n    switch(kind){\n      case KEYS: return function keys(){ return new Constructor(this, kind); };\n      case VALUES: return function values(){ return new Constructor(this, kind); };\n    } return function entries(){ return new Constructor(this, kind); };\n  };\n  var TAG        = NAME + ' Iterator'\n    , DEF_VALUES = DEFAULT == VALUES\n    , VALUES_BUG = false\n    , proto      = Base.prototype\n    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]\n    , $default   = $native || getMethod(DEFAULT)\n    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined\n    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native\n    , methods, key, IteratorPrototype;\n  // Fix native\n  if($anyNative){\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));\n    if(IteratorPrototype !== Object.prototype){\n      // Set @@toStringTag to native iterators\n      setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if(DEF_VALUES && $native && $native.name !== VALUES){\n    VALUES_BUG = true;\n    $default = function values(){ return $native.call(this); };\n  }\n  // Define iterator\n  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG]  = returnThis;\n  if(DEFAULT){\n    methods = {\n      values:  DEF_VALUES ? $default : getMethod(VALUES),\n      keys:    IS_SET     ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if(FORCED)for(key in methods){\n      if(!(key in proto))redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_iter-define.js\n ** module id = 49\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_iter-define.js?");

/***/ },
/* 50 */
/***/ function(module, exports) {

	eval("module.exports = true;\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_library.js\n ** module id = 50\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_library.js?");

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports = __webpack_require__(27);\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_redefine.js\n ** module id = 51\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_redefine.js?");

/***/ },
/* 52 */
/***/ function(module, exports) {

	eval("module.exports = {};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_iterators.js\n ** module id = 52\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_iterators.js?");

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar create         = __webpack_require__(54)\n  , descriptor     = __webpack_require__(36)\n  , setToStringTag = __webpack_require__(57)\n  , IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n__webpack_require__(27)(IteratorPrototype, __webpack_require__(58)('iterator'), function(){ return this; });\n\nmodule.exports = function(Constructor, NAME, next){\n  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_iter-create.js\n ** module id = 53\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_iter-create.js?");

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	eval("// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject    = __webpack_require__(29)\n  , dPs         = __webpack_require__(55)\n  , enumBugKeys = __webpack_require__(21)\n  , IE_PROTO    = __webpack_require__(17)('IE_PROTO')\n  , Empty       = function(){ /* empty */ }\n  , PROTOTYPE   = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function(){\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = __webpack_require__(34)('iframe')\n    , i      = enumBugKeys.length\n    , lt     = '<'\n    , gt     = '>'\n    , iframeDocument;\n  iframe.style.display = 'none';\n  __webpack_require__(56).appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties){\n  var result;\n  if(O !== null){\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty;\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : dPs(result, Properties);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_object-create.js\n ** module id = 54\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_object-create.js?");

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	eval("var dP       = __webpack_require__(28)\n  , anObject = __webpack_require__(29)\n  , getKeys  = __webpack_require__(7);\n\nmodule.exports = __webpack_require__(32) ? Object.defineProperties : function defineProperties(O, Properties){\n  anObject(O);\n  var keys   = getKeys(Properties)\n    , length = keys.length\n    , i = 0\n    , P;\n  while(length > i)dP.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_object-dps.js\n ** module id = 55\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_object-dps.js?");

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports = __webpack_require__(19).document && document.documentElement;\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_html.js\n ** module id = 56\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_html.js?");

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	eval("var def = __webpack_require__(28).f\n  , has = __webpack_require__(9)\n  , TAG = __webpack_require__(58)('toStringTag');\n\nmodule.exports = function(it, tag, stat){\n  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_set-to-string-tag.js\n ** module id = 57\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_set-to-string-tag.js?");

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	eval("var store      = __webpack_require__(18)('wks')\n  , uid        = __webpack_require__(20)\n  , Symbol     = __webpack_require__(19).Symbol\n  , USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function(name){\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_wks.js\n ** module id = 58\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_wks.js?");

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	eval("// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar has         = __webpack_require__(9)\n  , toObject    = __webpack_require__(5)\n  , IE_PROTO    = __webpack_require__(17)('IE_PROTO')\n  , ObjectProto = Object.prototype;\n\nmodule.exports = Object.getPrototypeOf || function(O){\n  O = toObject(O);\n  if(has(O, IE_PROTO))return O[IE_PROTO];\n  if(typeof O.constructor == 'function' && O instanceof O.constructor){\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_object-gpo.js\n ** module id = 59\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_object-gpo.js?");

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(61);\nvar global        = __webpack_require__(19)\n  , hide          = __webpack_require__(27)\n  , Iterators     = __webpack_require__(52)\n  , TO_STRING_TAG = __webpack_require__(58)('toStringTag');\n\nfor(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){\n  var NAME       = collections[i]\n    , Collection = global[NAME]\n    , proto      = Collection && Collection.prototype;\n  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);\n  Iterators[NAME] = Iterators.Array;\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/web.dom.iterable.js\n ** module id = 60\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/web.dom.iterable.js?");

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar addToUnscopables = __webpack_require__(62)\n  , step             = __webpack_require__(63)\n  , Iterators        = __webpack_require__(52)\n  , toIObject        = __webpack_require__(10);\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = __webpack_require__(49)(Array, 'Array', function(iterated, kind){\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , kind  = this._k\n    , index = this._i++;\n  if(!O || index >= O.length){\n    this._t = undefined;\n    return step(1);\n  }\n  if(kind == 'keys'  )return step(0, index);\n  if(kind == 'values')return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/es6.array.iterator.js\n ** module id = 61\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/es6.array.iterator.js?");

/***/ },
/* 62 */
/***/ function(module, exports) {

	eval("module.exports = function(){ /* empty */ };\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_add-to-unscopables.js\n ** module id = 62\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_add-to-unscopables.js?");

/***/ },
/* 63 */
/***/ function(module, exports) {

	eval("module.exports = function(done, value){\n  return {value: value, done: !!done};\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_iter-step.js\n ** module id = 63\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_iter-step.js?");

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar strong = __webpack_require__(65);\n\n// 23.1 Map Objects\nmodule.exports = __webpack_require__(75)('Map', function(get){\n  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };\n}, {\n  // 23.1.3.6 Map.prototype.get(key)\n  get: function get(key){\n    var entry = strong.getEntry(this, key);\n    return entry && entry.v;\n  },\n  // 23.1.3.9 Map.prototype.set(key, value)\n  set: function set(key, value){\n    return strong.def(this, key === 0 ? 0 : key, value);\n  }\n}, strong, true);\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/es6.map.js\n ** module id = 64\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/es6.map.js?");

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar dP          = __webpack_require__(28).f\n  , create      = __webpack_require__(54)\n  , redefineAll = __webpack_require__(66)\n  , ctx         = __webpack_require__(25)\n  , anInstance  = __webpack_require__(67)\n  , defined     = __webpack_require__(6)\n  , forOf       = __webpack_require__(68)\n  , $iterDefine = __webpack_require__(49)\n  , step        = __webpack_require__(63)\n  , setSpecies  = __webpack_require__(73)\n  , DESCRIPTORS = __webpack_require__(32)\n  , fastKey     = __webpack_require__(74).fastKey\n  , SIZE        = DESCRIPTORS ? '_s' : 'size';\n\nvar getEntry = function(that, key){\n  // fast case\n  var index = fastKey(key), entry;\n  if(index !== 'F')return that._i[index];\n  // frozen object case\n  for(entry = that._f; entry; entry = entry.n){\n    if(entry.k == key)return entry;\n  }\n};\n\nmodule.exports = {\n  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){\n    var C = wrapper(function(that, iterable){\n      anInstance(that, C, NAME, '_i');\n      that._i = create(null); // index\n      that._f = undefined;    // first entry\n      that._l = undefined;    // last entry\n      that[SIZE] = 0;         // size\n      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);\n    });\n    redefineAll(C.prototype, {\n      // 23.1.3.1 Map.prototype.clear()\n      // 23.2.3.2 Set.prototype.clear()\n      clear: function clear(){\n        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){\n          entry.r = true;\n          if(entry.p)entry.p = entry.p.n = undefined;\n          delete data[entry.i];\n        }\n        that._f = that._l = undefined;\n        that[SIZE] = 0;\n      },\n      // 23.1.3.3 Map.prototype.delete(key)\n      // 23.2.3.4 Set.prototype.delete(value)\n      'delete': function(key){\n        var that  = this\n          , entry = getEntry(that, key);\n        if(entry){\n          var next = entry.n\n            , prev = entry.p;\n          delete that._i[entry.i];\n          entry.r = true;\n          if(prev)prev.n = next;\n          if(next)next.p = prev;\n          if(that._f == entry)that._f = next;\n          if(that._l == entry)that._l = prev;\n          that[SIZE]--;\n        } return !!entry;\n      },\n      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)\n      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)\n      forEach: function forEach(callbackfn /*, that = undefined */){\n        anInstance(this, C, 'forEach');\n        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)\n          , entry;\n        while(entry = entry ? entry.n : this._f){\n          f(entry.v, entry.k, this);\n          // revert to the last existing entry\n          while(entry && entry.r)entry = entry.p;\n        }\n      },\n      // 23.1.3.7 Map.prototype.has(key)\n      // 23.2.3.7 Set.prototype.has(value)\n      has: function has(key){\n        return !!getEntry(this, key);\n      }\n    });\n    if(DESCRIPTORS)dP(C.prototype, 'size', {\n      get: function(){\n        return defined(this[SIZE]);\n      }\n    });\n    return C;\n  },\n  def: function(that, key, value){\n    var entry = getEntry(that, key)\n      , prev, index;\n    // change existing entry\n    if(entry){\n      entry.v = value;\n    // create new entry\n    } else {\n      that._l = entry = {\n        i: index = fastKey(key, true), // <- index\n        k: key,                        // <- key\n        v: value,                      // <- value\n        p: prev = that._l,             // <- previous entry\n        n: undefined,                  // <- next entry\n        r: false                       // <- removed\n      };\n      if(!that._f)that._f = entry;\n      if(prev)prev.n = entry;\n      that[SIZE]++;\n      // add to index\n      if(index !== 'F')that._i[index] = entry;\n    } return that;\n  },\n  getEntry: getEntry,\n  setStrong: function(C, NAME, IS_MAP){\n    // add .keys, .values, .entries, [@@iterator]\n    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11\n    $iterDefine(C, NAME, function(iterated, kind){\n      this._t = iterated;  // target\n      this._k = kind;      // kind\n      this._l = undefined; // previous\n    }, function(){\n      var that  = this\n        , kind  = that._k\n        , entry = that._l;\n      // revert to the last existing entry\n      while(entry && entry.r)entry = entry.p;\n      // get next entry\n      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){\n        // or finish the iteration\n        that._t = undefined;\n        return step(1);\n      }\n      // return step by kind\n      if(kind == 'keys'  )return step(0, entry.k);\n      if(kind == 'values')return step(0, entry.v);\n      return step(0, [entry.k, entry.v]);\n    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);\n\n    // add [@@species], 23.1.2.2, 23.2.2.2\n    setSpecies(NAME);\n  }\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_collection-strong.js\n ** module id = 65\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_collection-strong.js?");

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	eval("var hide = __webpack_require__(27);\nmodule.exports = function(target, src, safe){\n  for(var key in src){\n    if(safe && target[key])target[key] = src[key];\n    else hide(target, key, src[key]);\n  } return target;\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_redefine-all.js\n ** module id = 66\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_redefine-all.js?");

/***/ },
/* 67 */
/***/ function(module, exports) {

	eval("module.exports = function(it, Constructor, name, forbiddenField){\n  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){\n    throw TypeError(name + ': incorrect invocation!');\n  } return it;\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_an-instance.js\n ** module id = 67\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_an-instance.js?");

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	eval("var ctx         = __webpack_require__(25)\n  , call        = __webpack_require__(69)\n  , isArrayIter = __webpack_require__(70)\n  , anObject    = __webpack_require__(29)\n  , toLength    = __webpack_require__(14)\n  , getIterFn   = __webpack_require__(71)\n  , BREAK       = {}\n  , RETURN      = {};\nvar exports = module.exports = function(iterable, entries, fn, that, ITERATOR){\n  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)\n    , f      = ctx(fn, that, entries ? 2 : 1)\n    , index  = 0\n    , length, step, iterator, result;\n  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');\n  // fast case for arrays with default iterator\n  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){\n    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);\n    if(result === BREAK || result === RETURN)return result;\n  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){\n    result = call(iterator, f, step.value, entries);\n    if(result === BREAK || result === RETURN)return result;\n  }\n};\nexports.BREAK  = BREAK;\nexports.RETURN = RETURN;\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_for-of.js\n ** module id = 68\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_for-of.js?");

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	eval("// call something on iterator step with safe closing on error\nvar anObject = __webpack_require__(29);\nmodule.exports = function(iterator, fn, value, entries){\n  try {\n    return entries ? fn(anObject(value)[0], value[1]) : fn(value);\n  // 7.4.6 IteratorClose(iterator, completion)\n  } catch(e){\n    var ret = iterator['return'];\n    if(ret !== undefined)anObject(ret.call(iterator));\n    throw e;\n  }\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_iter-call.js\n ** module id = 69\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_iter-call.js?");

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	eval("// check on default Array iterator\nvar Iterators  = __webpack_require__(52)\n  , ITERATOR   = __webpack_require__(58)('iterator')\n  , ArrayProto = Array.prototype;\n\nmodule.exports = function(it){\n  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_is-array-iter.js\n ** module id = 70\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_is-array-iter.js?");

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	eval("var classof   = __webpack_require__(72)\n  , ITERATOR  = __webpack_require__(58)('iterator')\n  , Iterators = __webpack_require__(52);\nmodule.exports = __webpack_require__(24).getIteratorMethod = function(it){\n  if(it != undefined)return it[ITERATOR]\n    || it['@@iterator']\n    || Iterators[classof(it)];\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/core.get-iterator-method.js\n ** module id = 71\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/core.get-iterator-method.js?");

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	eval("// getting tag from 19.1.3.6 Object.prototype.toString()\nvar cof = __webpack_require__(12)\n  , TAG = __webpack_require__(58)('toStringTag')\n  // ES3 wrong here\n  , ARG = cof(function(){ return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function(it, key){\n  try {\n    return it[key];\n  } catch(e){ /* empty */ }\n};\n\nmodule.exports = function(it){\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n    // builtinTag case\n    : ARG ? cof(O)\n    // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_classof.js\n ** module id = 72\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_classof.js?");

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar global      = __webpack_require__(19)\n  , core        = __webpack_require__(24)\n  , dP          = __webpack_require__(28)\n  , DESCRIPTORS = __webpack_require__(32)\n  , SPECIES     = __webpack_require__(58)('species');\n\nmodule.exports = function(KEY){\n  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];\n  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {\n    configurable: true,\n    get: function(){ return this; }\n  });\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_set-species.js\n ** module id = 73\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_set-species.js?");

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	eval("var META     = __webpack_require__(20)('meta')\n  , isObject = __webpack_require__(30)\n  , has      = __webpack_require__(9)\n  , setDesc  = __webpack_require__(28).f\n  , id       = 0;\nvar isExtensible = Object.isExtensible || function(){\n  return true;\n};\nvar FREEZE = !__webpack_require__(33)(function(){\n  return isExtensible(Object.preventExtensions({}));\n});\nvar setMeta = function(it){\n  setDesc(it, META, {value: {\n    i: 'O' + ++id, // object ID\n    w: {}          // weak collections IDs\n  }});\n};\nvar fastKey = function(it, create){\n  // return primitive with prefix\n  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n  if(!has(it, META)){\n    // can't set metadata to uncaught frozen object\n    if(!isExtensible(it))return 'F';\n    // not necessary to add metadata\n    if(!create)return 'E';\n    // add missing metadata\n    setMeta(it);\n  // return object ID\n  } return it[META].i;\n};\nvar getWeak = function(it, create){\n  if(!has(it, META)){\n    // can't set metadata to uncaught frozen object\n    if(!isExtensible(it))return true;\n    // not necessary to add metadata\n    if(!create)return false;\n    // add missing metadata\n    setMeta(it);\n  // return hash weak collections IDs\n  } return it[META].w;\n};\n// add metadata on freeze-family methods calling\nvar onFreeze = function(it){\n  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);\n  return it;\n};\nvar meta = module.exports = {\n  KEY:      META,\n  NEED:     false,\n  fastKey:  fastKey,\n  getWeak:  getWeak,\n  onFreeze: onFreeze\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_meta.js\n ** module id = 74\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_meta.js?");

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar global         = __webpack_require__(19)\n  , $export        = __webpack_require__(23)\n  , meta           = __webpack_require__(74)\n  , fails          = __webpack_require__(33)\n  , hide           = __webpack_require__(27)\n  , redefineAll    = __webpack_require__(66)\n  , forOf          = __webpack_require__(68)\n  , anInstance     = __webpack_require__(67)\n  , isObject       = __webpack_require__(30)\n  , setToStringTag = __webpack_require__(57)\n  , dP             = __webpack_require__(28).f\n  , each           = __webpack_require__(76)(0)\n  , DESCRIPTORS    = __webpack_require__(32);\n\nmodule.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){\n  var Base  = global[NAME]\n    , C     = Base\n    , ADDER = IS_MAP ? 'set' : 'add'\n    , proto = C && C.prototype\n    , O     = {};\n  if(!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){\n    new C().entries().next();\n  }))){\n    // create collection constructor\n    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);\n    redefineAll(C.prototype, methods);\n    meta.NEED = true;\n  } else {\n    C = wrapper(function(target, iterable){\n      anInstance(target, C, NAME, '_c');\n      target._c = new Base;\n      if(iterable != undefined)forOf(iterable, IS_MAP, target[ADDER], target);\n    });\n    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','),function(KEY){\n      var IS_ADDER = KEY == 'add' || KEY == 'set';\n      if(KEY in proto && !(IS_WEAK && KEY == 'clear'))hide(C.prototype, KEY, function(a, b){\n        anInstance(this, C, KEY);\n        if(!IS_ADDER && IS_WEAK && !isObject(a))return KEY == 'get' ? undefined : false;\n        var result = this._c[KEY](a === 0 ? 0 : a, b);\n        return IS_ADDER ? this : result;\n      });\n    });\n    if('size' in proto)dP(C.prototype, 'size', {\n      get: function(){\n        return this._c.size;\n      }\n    });\n  }\n\n  setToStringTag(C, NAME);\n\n  O[NAME] = C;\n  $export($export.G + $export.W + $export.F, O);\n\n  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);\n\n  return C;\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_collection.js\n ** module id = 75\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_collection.js?");

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	eval("// 0 -> Array#forEach\n// 1 -> Array#map\n// 2 -> Array#filter\n// 3 -> Array#some\n// 4 -> Array#every\n// 5 -> Array#find\n// 6 -> Array#findIndex\nvar ctx      = __webpack_require__(25)\n  , IObject  = __webpack_require__(11)\n  , toObject = __webpack_require__(5)\n  , toLength = __webpack_require__(14)\n  , asc      = __webpack_require__(77);\nmodule.exports = function(TYPE, $create){\n  var IS_MAP        = TYPE == 1\n    , IS_FILTER     = TYPE == 2\n    , IS_SOME       = TYPE == 3\n    , IS_EVERY      = TYPE == 4\n    , IS_FIND_INDEX = TYPE == 6\n    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX\n    , create        = $create || asc;\n  return function($this, callbackfn, that){\n    var O      = toObject($this)\n      , self   = IObject(O)\n      , f      = ctx(callbackfn, that, 3)\n      , length = toLength(self.length)\n      , index  = 0\n      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined\n      , val, res;\n    for(;length > index; index++)if(NO_HOLES || index in self){\n      val = self[index];\n      res = f(val, index, O);\n      if(TYPE){\n        if(IS_MAP)result[index] = res;            // map\n        else if(res)switch(TYPE){\n          case 3: return true;                    // some\n          case 5: return val;                     // find\n          case 6: return index;                   // findIndex\n          case 2: result.push(val);               // filter\n        } else if(IS_EVERY)return false;          // every\n      }\n    }\n    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;\n  };\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_array-methods.js\n ** module id = 76\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_array-methods.js?");

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	eval("// 9.4.2.3 ArraySpeciesCreate(originalArray, length)\nvar speciesConstructor = __webpack_require__(78);\n\nmodule.exports = function(original, length){\n  return new (speciesConstructor(original))(length);\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_array-species-create.js\n ** module id = 77\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_array-species-create.js?");

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	eval("var isObject = __webpack_require__(30)\n  , isArray  = __webpack_require__(79)\n  , SPECIES  = __webpack_require__(58)('species');\n\nmodule.exports = function(original){\n  var C;\n  if(isArray(original)){\n    C = original.constructor;\n    // cross-realm fallback\n    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;\n    if(isObject(C)){\n      C = C[SPECIES];\n      if(C === null)C = undefined;\n    }\n  } return C === undefined ? Array : C;\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_array-species-constructor.js\n ** module id = 78\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_array-species-constructor.js?");

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	eval("// 7.2.2 IsArray(argument)\nvar cof = __webpack_require__(12);\nmodule.exports = Array.isArray || function isArray(arg){\n  return cof(arg) == 'Array';\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_is-array.js\n ** module id = 79\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_is-array.js?");

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	eval("// https://github.com/DavidBruant/Map-Set.prototype.toJSON\nvar $export  = __webpack_require__(23);\n\n$export($export.P + $export.R, 'Map', {toJSON: __webpack_require__(81)('Map')});\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/es7.map.to-json.js\n ** module id = 80\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/es7.map.to-json.js?");

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	eval("// https://github.com/DavidBruant/Map-Set.prototype.toJSON\nvar classof = __webpack_require__(72)\n  , from    = __webpack_require__(82);\nmodule.exports = function(NAME){\n  return function toJSON(){\n    if(classof(this) != NAME)throw TypeError(NAME + \"#toJSON isn't generic\");\n    return from(this);\n  };\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_collection-to-json.js\n ** module id = 81\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_collection-to-json.js?");

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	eval("var forOf = __webpack_require__(68);\n\nmodule.exports = function(iter, ITERATOR){\n  var result = [];\n  forOf(iter, false, result.push, result, ITERATOR);\n  return result;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_array-from-iterable.js\n ** module id = 82\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/core-js/library/modules/_array-from-iterable.js?");

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	eval("var get = __webpack_require__(84)\nvar CreateSignalFactory = __webpack_require__(132)\nvar CreateRegisterModules = __webpack_require__(144)\nvar EventEmitter = __webpack_require__(145).EventEmitter\nvar Computed = __webpack_require__(146)\n\nvar Controller = function (Model) {\n  var controller = new EventEmitter()\n  var model = Model(controller)\n  var signals = {}\n  var modules = {}\n  var services = {}\n  var externalContextProviders = {__cerebral_global__: []}\n\n  var signalFactory = CreateSignalFactory(controller, externalContextProviders)\n  var signal = function () {\n    var signalNamePath = arguments[0].split('.')\n    var signalName = signalNamePath.pop()\n    var signalMethodPath = signals\n    while (signalNamePath.length) {\n      var pathName = signalNamePath.shift()\n      signalMethodPath = signalMethodPath[pathName] = signalMethodPath[pathName] || {}\n    }\n    var signal = signalMethodPath[signalName] = signalFactory.apply(null, arguments)\n    return signal\n  }\n  var service = function (name, service) {\n    var serviceNamePath = name.split('.')\n    var serviceName = serviceNamePath.pop()\n    var serviceMethodPath = services\n    while (serviceNamePath.length) {\n      var pathName = serviceNamePath.shift()\n      serviceMethodPath = serviceMethodPath[pathName] = serviceMethodPath[pathName] || {}\n    }\n    serviceMethodPath[serviceName] = service\n    return service\n  }\n\n  controller.getSignals = function (path) {\n    return path\n      ? get(signals, path)\n      : signals\n  }\n  controller.getServices = function (path) {\n    return path\n      ? get(services, path)\n      : services\n  }\n  controller.getModel = function () {\n    return model\n  }\n  controller.get = function (path) {\n    return model.accessors.get(typeof path === 'string' ? path.split('.') : path)\n  }\n  controller.logModel = function () {\n    return model.logModel()\n  }\n  controller.getModules = function (moduleName) {\n    return moduleName\n      ? modules[moduleName]\n      : modules\n  }\n\n  controller.addModules = CreateRegisterModules(controller, model, modules)\n\n  controller.addSignals = function (signals, options) {\n    Object.keys(signals).forEach(function (name) {\n      if (signals[name].chain) {\n        var optionsCopy = Object.keys(options || {}).reduce(function (optionsCopy, key) {\n          optionsCopy[key] = options[key]\n          return optionsCopy\n        }, {})\n        var signalOptions = Object.keys(signals[name]).reduce(function (signalOptions, key) {\n          if (key !== 'chain') {\n            signalOptions[key] = signals[name][key]\n          }\n          return signalOptions\n        }, optionsCopy)\n        signal(name, signals[name].chain, signalOptions)\n      } else {\n        signal(name, signals[name], options)\n      }\n    })\n  }\n  controller.addServices = function (newServices) {\n    Object.keys(newServices).forEach(function (key) {\n      service(key, newServices[key])\n    })\n    return controller.getServices()\n  }\n  controller.addContextProvider = function (provider, scope) {\n    if (scope) {\n      if (!externalContextProviders[scope]) {\n        externalContextProviders[scope] = []\n      }\n      externalContextProviders[scope].push(provider)\n    } else {\n      externalContextProviders.__cerebral_global__.push(provider)\n    }\n    externalContextProviders[scope || '__cerebral_global__'].push(provider)\n  }\n\n  controller.on('flush', Computed.updateCache)\n\n  return controller\n}\n\nmodule.exports.Controller = Controller\nmodule.exports.Computed = Computed\nmodule.exports.ServerController = function (state) {\n  var model = {\n    accessors: {\n      get: function (path) {\n        path = typeof path === 'string' ? path.split('.') : path\n        return path.reduce(function (currentState, key) {\n          return currentState[key]\n        }, state)\n      }\n    }\n  }\n\n  return {\n    isServer: true,\n    get: function (path) {\n      return model.accessors.get(path)\n    }\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/cerebral/src/index.js\n ** module id = 83\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/cerebral/src/index.js?");

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	eval("var baseGet = __webpack_require__(85);\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/get.js\n ** module id = 84\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/get.js?");

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	eval("var castPath = __webpack_require__(86),\n    isKey = __webpack_require__(130),\n    toKey = __webpack_require__(131);\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nmodule.exports = baseGet;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_baseGet.js\n ** module id = 85\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_baseGet.js?");

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	eval("var isArray = __webpack_require__(87),\n    stringToPath = __webpack_require__(88);\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value) {\n  return isArray(value) ? value : stringToPath(value);\n}\n\nmodule.exports = castPath;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_castPath.js\n ** module id = 86\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_castPath.js?");

/***/ },
/* 87 */
/***/ function(module, exports) {

	eval("/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/isArray.js\n ** module id = 87\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/isArray.js?");

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	eval("var memoize = __webpack_require__(89),\n    toString = __webpack_require__(125);\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(\\.|\\[\\])(?:\\4|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoize(function(string) {\n  var result = [];\n  toString(string).replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nmodule.exports = stringToPath;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_stringToPath.js\n ** module id = 88\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_stringToPath.js?");

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	eval("var MapCache = __webpack_require__(90);\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result);\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Assign cache to `_.memoize`.\nmemoize.Cache = MapCache;\n\nmodule.exports = memoize;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/memoize.js\n ** module id = 89\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/memoize.js?");

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	eval("var mapCacheClear = __webpack_require__(91),\n    mapCacheDelete = __webpack_require__(119),\n    mapCacheGet = __webpack_require__(122),\n    mapCacheHas = __webpack_require__(123),\n    mapCacheSet = __webpack_require__(124);\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nmodule.exports = MapCache;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_MapCache.js\n ** module id = 90\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_MapCache.js?");

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	eval("var Hash = __webpack_require__(92),\n    ListCache = __webpack_require__(110),\n    Map = __webpack_require__(118);\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nmodule.exports = mapCacheClear;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_mapCacheClear.js\n ** module id = 91\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_mapCacheClear.js?");

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	eval("var hashClear = __webpack_require__(93),\n    hashDelete = __webpack_require__(106),\n    hashGet = __webpack_require__(107),\n    hashHas = __webpack_require__(108),\n    hashSet = __webpack_require__(109);\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nmodule.exports = Hash;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_Hash.js\n ** module id = 92\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_Hash.js?");

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	eval("var nativeCreate = __webpack_require__(94);\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\nmodule.exports = hashClear;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_hashClear.js\n ** module id = 93\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_hashClear.js?");

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	eval("var getNative = __webpack_require__(95);\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nmodule.exports = nativeCreate;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_nativeCreate.js\n ** module id = 94\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_nativeCreate.js?");

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	eval("var baseIsNative = __webpack_require__(96),\n    getValue = __webpack_require__(105);\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_getNative.js\n ** module id = 95\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_getNative.js?");

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	eval("var isFunction = __webpack_require__(97),\n    isHostObject = __webpack_require__(99),\n    isMasked = __webpack_require__(100),\n    isObject = __webpack_require__(98),\n    toSource = __webpack_require__(104);\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = Function.prototype.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_baseIsNative.js\n ** module id = 96\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_baseIsNative.js?");

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	eval("var isObject = __webpack_require__(98);\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8 which returns 'object' for typed array and weak map constructors,\n  // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\nmodule.exports = isFunction;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/isFunction.js\n ** module id = 97\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/isFunction.js?");

/***/ },
/* 98 */
/***/ function(module, exports) {

	eval("/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/isObject.js\n ** module id = 98\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/isObject.js?");

/***/ },
/* 99 */
/***/ function(module, exports) {

	eval("/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\nmodule.exports = isHostObject;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_isHostObject.js\n ** module id = 99\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_isHostObject.js?");

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	eval("var coreJsData = __webpack_require__(101);\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_isMasked.js\n ** module id = 100\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_isMasked.js?");

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	eval("var root = __webpack_require__(102);\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_coreJsData.js\n ** module id = 101\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_coreJsData.js?");

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	eval("var freeGlobal = __webpack_require__(103);\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_root.js\n ** module id = 102\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_root.js?");

/***/ },
/* 103 */
/***/ function(module, exports) {

	eval("/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_freeGlobal.js\n ** module id = 103\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_freeGlobal.js?");

/***/ },
/* 104 */
/***/ function(module, exports) {

	eval("/** Used to resolve the decompiled source of functions. */\nvar funcToString = Function.prototype.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_toSource.js\n ** module id = 104\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_toSource.js?");

/***/ },
/* 105 */
/***/ function(module, exports) {

	eval("/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_getValue.js\n ** module id = 105\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_getValue.js?");

/***/ },
/* 106 */
/***/ function(module, exports) {

	eval("/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\nmodule.exports = hashDelete;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_hashDelete.js\n ** module id = 106\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_hashDelete.js?");

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	eval("var nativeCreate = __webpack_require__(94);\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nmodule.exports = hashGet;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_hashGet.js\n ** module id = 107\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_hashGet.js?");

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	eval("var nativeCreate = __webpack_require__(94);\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\nmodule.exports = hashHas;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_hashHas.js\n ** module id = 108\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_hashHas.js?");

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	eval("var nativeCreate = __webpack_require__(94);\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nmodule.exports = hashSet;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_hashSet.js\n ** module id = 109\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_hashSet.js?");

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	eval("var listCacheClear = __webpack_require__(111),\n    listCacheDelete = __webpack_require__(112),\n    listCacheGet = __webpack_require__(115),\n    listCacheHas = __webpack_require__(116),\n    listCacheSet = __webpack_require__(117);\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nmodule.exports = ListCache;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_ListCache.js\n ** module id = 110\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_ListCache.js?");

/***/ },
/* 111 */
/***/ function(module, exports) {

	eval("/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\nmodule.exports = listCacheClear;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_listCacheClear.js\n ** module id = 111\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_listCacheClear.js?");

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	eval("var assocIndexOf = __webpack_require__(113);\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\nmodule.exports = listCacheDelete;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_listCacheDelete.js\n ** module id = 112\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_listCacheDelete.js?");

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	eval("var eq = __webpack_require__(114);\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to search.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = assocIndexOf;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_assocIndexOf.js\n ** module id = 113\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_assocIndexOf.js?");

/***/ },
/* 114 */
/***/ function(module, exports) {

	eval("/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nmodule.exports = eq;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/eq.js\n ** module id = 114\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/eq.js?");

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	eval("var assocIndexOf = __webpack_require__(113);\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nmodule.exports = listCacheGet;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_listCacheGet.js\n ** module id = 115\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_listCacheGet.js?");

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	eval("var assocIndexOf = __webpack_require__(113);\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nmodule.exports = listCacheHas;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_listCacheHas.js\n ** module id = 116\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_listCacheHas.js?");

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	eval("var assocIndexOf = __webpack_require__(113);\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nmodule.exports = listCacheSet;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_listCacheSet.js\n ** module id = 117\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_listCacheSet.js?");

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	eval("var getNative = __webpack_require__(95),\n    root = __webpack_require__(102);\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nmodule.exports = Map;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_Map.js\n ** module id = 118\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_Map.js?");

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	eval("var getMapData = __webpack_require__(120);\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\nmodule.exports = mapCacheDelete;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_mapCacheDelete.js\n ** module id = 119\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_mapCacheDelete.js?");

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	eval("var isKeyable = __webpack_require__(121);\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nmodule.exports = getMapData;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_getMapData.js\n ** module id = 120\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_getMapData.js?");

/***/ },
/* 121 */
/***/ function(module, exports) {

	eval("/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nmodule.exports = isKeyable;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_isKeyable.js\n ** module id = 121\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_isKeyable.js?");

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	eval("var getMapData = __webpack_require__(120);\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nmodule.exports = mapCacheGet;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_mapCacheGet.js\n ** module id = 122\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_mapCacheGet.js?");

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	eval("var getMapData = __webpack_require__(120);\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nmodule.exports = mapCacheHas;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_mapCacheHas.js\n ** module id = 123\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_mapCacheHas.js?");

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	eval("var getMapData = __webpack_require__(120);\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\nmodule.exports = mapCacheSet;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_mapCacheSet.js\n ** module id = 124\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_mapCacheSet.js?");

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	eval("var baseToString = __webpack_require__(126);\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nmodule.exports = toString;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/toString.js\n ** module id = 125\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/toString.js?");

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	eval("var Symbol = __webpack_require__(127),\n    isSymbol = __webpack_require__(128);\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = baseToString;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_baseToString.js\n ** module id = 126\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_baseToString.js?");

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	eval("var root = __webpack_require__(102);\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_Symbol.js\n ** module id = 127\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_Symbol.js?");

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	eval("var isObjectLike = __webpack_require__(129);\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/isSymbol.js\n ** module id = 128\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/isSymbol.js?");

/***/ },
/* 129 */
/***/ function(module, exports) {

	eval("/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/isObjectLike.js\n ** module id = 129\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/isObjectLike.js?");

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	eval("var isArray = __webpack_require__(87),\n    isSymbol = __webpack_require__(128);\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nmodule.exports = isKey;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_isKey.js\n ** module id = 130\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_isKey.js?");

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	eval("var isSymbol = __webpack_require__(128);\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = toKey;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/lodash/_toKey.js\n ** module id = 131\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/lodash/_toKey.js?");

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(global) {var utils = __webpack_require__(133)\nvar analyze = __webpack_require__(136)\nvar staticTree = __webpack_require__(137)\nvar createContext = __webpack_require__(138)\nvar inputProvider = __webpack_require__(139)\nvar stateProvider = __webpack_require__(140)\nvar servicesProvider = __webpack_require__(141)\nvar outputProvider = __webpack_require__(142)\nvar deprecationProvider = __webpack_require__(143)\n\nvar requestAnimationFrame = global.requestAnimationFrame || function (cb) {\n  setTimeout(cb, 0)\n}\n\nmodule.exports = function (controller, externalContextProviders) {\n  var currentlyRunningSignals = 0\n  var batchedSignals = []\n  var pending = false\n\n  controller.isExecuting = function () {\n    return Boolean(currentlyRunningSignals)\n  }\n\n  return function (signalName, chain, defaultOptions) {\n    if (utils.isDeveloping()) {\n      analyze(signalName, chain || [])\n    }\n\n    var signalChain = function (signalPayload, passedOptions) {\n      var defaultOptionsCopy = Object.keys(defaultOptions || {}).reduce(function (defaultOptionsCopy, key) {\n        defaultOptionsCopy[key] = defaultOptions[key]\n        return defaultOptionsCopy\n      }, {})\n      var options = Object.keys(passedOptions || {}).reduce(function (defaultOptionsCopy, key) {\n        defaultOptionsCopy[key] = passedOptions[key]\n        return defaultOptionsCopy\n      }, defaultOptionsCopy)\n\n      var tree = staticTree(signalChain.chain)\n      var actions = tree.actions\n\n      var signal = {\n        name: signalName,\n        start: null,\n        isSync: options.immediate,\n        isExecuting: false,\n        isPrevented: false,\n        branches: tree.branches,\n        duration: 0,\n        preventSignalRun: function () {\n          if (signal.isExecuting === false) signal.isPrevented = true\n        }\n      }\n\n      var isPredefinedExecution = false\n      if (options.branches) {\n        signal.isSync = true\n        signal.branches = options.branches\n        isPredefinedExecution = true\n        controller.emit('predefinedSignal', { signal: signal, options: options, payload: signalPayload })\n      } else {\n        controller.emit('signalTrigger', { signal: signal, options: options, payload: signalPayload })\n      }\n\n      if (signal.isPrevented) {\n        return\n      }\n\n      var runSignal = function () {\n        signal.start = Date.now()\n        signal.isExecuting = true\n\n        if (!isPredefinedExecution) {\n          currentlyRunningSignals++\n          controller.emit('signalStart', {signal: signal, options: options, payload: signalPayload})\n        }\n\n        var runBranch = function (branch, index, start, payload) {\n          var currentBranch = branch[index]\n          if (!currentBranch) {\n            if (branch === signal.branches && !isPredefinedExecution) {\n              // Might not be any actions passed\n              if (branch[index - 1]) {\n                branch[index - 1].duration = Date.now() - start\n              }\n\n              signal.isExecuting = false\n              currentlyRunningSignals--\n              controller.emit('signalEnd', {signal: signal, options: options, payload: payload})\n              controller.emit('change', {signal: signal, options: options, payload: payload})\n            }\n            return\n          }\n\n          if (Array.isArray(currentBranch)) {\n            if (isPredefinedExecution) {\n              currentBranch.forEach(function (action) {\n                // If any signals has run with this action, run them\n                // as well\n                if (action.signals) {\n                  action.signals.forEach(function (signal) {\n                    var signalMethodPath = signal.name.split('.').reduce(function (signals, key) {\n                      return signals[key]\n                    }, controller.getSignals())\n                    signalMethodPath(signal.input, {branches: signal.branches})\n                  })\n                }\n\n                if (action.outputPath) {\n                  runBranch(action.outputs[action.outputPath], 0)\n                }\n              })\n\n              runBranch(branch, index + 1)\n            } else {\n              var resolvedPromisesCount = 0\n              var promises = currentBranch.map(function (action) {\n                var resolver = null\n                var promise = new Promise(function (resolve) {\n                  resolver = resolve\n                })\n                controller.emit('actionStart', {\n                  action: action,\n                  signal: signal,\n                  options: options,\n                  payload: payload\n                })\n                var actionFunc = actions[action.actionIndex]\n\n                var contextProviders = [\n                  inputProvider,\n                  stateProvider,\n                  servicesProvider,\n                  outputProvider\n                ].concat(utils.extractExternalContextProviders(externalContextProviders, options.modulePath))\n                .concat(utils.isDeveloping() ? deprecationProvider : [])\n                var context = createContext(contextProviders, {\n                  action: action,\n                  signal: signal,\n                  options: options,\n                  payload: payload,\n                  resolve: resolver\n                }, controller)\n\n                action.isExecuting = true\n\n                if (utils.isDeveloping()) {\n                  try {\n                    actionFunc(context)\n                  } catch (e) {\n                    action.error = {\n                      name: e.name,\n                      message: e.message,\n                      stack: actionFunc.toString()\n                    }\n                    controller.emit('signalError', {action: action, signal: signal, options: options, payload: payload})\n                    controller.emit('change', {signal: signal, options: options, payload: payload})\n                    throw e\n                  }\n                } else {\n                  actionFunc(context)\n                }\n\n                return promise.then(function (resolvedAction) {\n                  resolvedPromisesCount++\n                  action.hasExecuted = true\n                  action.isExecuting = false\n\n                  controller.emit('actionEnd', {action: action, signal: signal, options: options, payload: payload})\n\n                  var newPayload = utils.merge({}, payload, resolvedAction.payload)\n                  if (resolvedAction.path) {\n                    action.outputPath = resolvedAction.path\n                    newPayload = runBranch(action.outputs[resolvedAction.path], 0, Date.now(), newPayload) || newPayload\n                    if (!newPayload.then && resolvedPromisesCount !== currentBranch.length) {\n                      controller.emit('change', {signal: signal, options: options, payload: newPayload})\n                    }\n                  }\n                  return newPayload\n                })\n              })\n              controller.emit('change', {signal: signal, options: options, payload: payload})\n              return Promise.all(promises)\n                .then(function (actionPayloads) {\n                  var newPayload = utils.merge.apply(null, [{}, payload].concat(actionPayloads))\n                  return runBranch(branch, index + 1, Date.now(), newPayload) || newPayload\n                })\n                .catch(function (error) {\n                  // We just throw any unhandled errors\n                  controller.emit('error', error)\n                  throw error\n                })\n            }\n          } else {\n            var action = currentBranch\n\n            if (isPredefinedExecution) {\n              action.mutations.forEach(function (mutation) {\n                controller.getModel().mutators[mutation.name].apply(null, [mutation.path.slice()].concat(mutation.args))\n              })\n\n              if (action.outputPath) {\n                runBranch(action.outputs[action.outputPath], 0)\n              }\n\n              runBranch(branch, index + 1)\n            } else {\n              controller.emit('actionStart', {action: action, signal: signal, options: options, payload: payload})\n              var resolvedAction = {path: null, payload: {}}\n              var resolver = function (resolvedResult) {\n                resolvedAction = resolvedResult\n              }\n              var actionFunc = actions[action.actionIndex]\n\n              var contextProviders = [\n                inputProvider,\n                stateProvider,\n                servicesProvider,\n                outputProvider\n              ].concat(utils.extractExternalContextProviders(externalContextProviders, options.modulePath))\n              .concat(utils.isDeveloping() ? deprecationProvider : [])\n              var context = createContext(contextProviders, {\n                action: action,\n                signal: signal,\n                options: options,\n                payload: payload,\n                resolve: resolver\n              }, controller)\n\n              if (utils.isDeveloping()) {\n                try {\n                  actionFunc(context)\n                } catch (e) {\n                  action.error = {\n                    name: e.name,\n                    message: e.message,\n                    stack: e.stack\n                  }\n                  controller.emit('signalError', {action: action, signal: signal, options: options, payload: payload})\n                  controller.emit('change', {signal: signal, options: options, payload: payload})\n                  throw e\n                }\n              } else {\n                actionFunc(context)\n              }\n\n              action.isExecuting = false\n              action.hasExecuted = true\n\n              if (!branch[index + 1] || Array.isArray(branch[index + 1])) {\n                action.duration = Date.now() - start\n              }\n\n              var branchResult = null\n              var newPayload = utils.merge({}, payload, resolvedAction.payload)\n\n              if (resolvedAction.path) {\n                action.outputPath = resolvedAction.path\n                controller.emit('actionEnd', {action: action, signal: signal, options: options, payload: payload})\n                branchResult = runBranch(action.outputs[resolvedAction.path], 0, start, utils.merge({}, payload, resolvedAction.payload))\n                if (branchResult && branchResult.then) {\n                  return branchResult.then(function (payload) {\n                    return runBranch(branch, index + 1, Date.now(), utils.merge({}, payload, resolvedAction.payload))\n                  })\n                } else {\n                  return runBranch(branch, index + 1, start, utils.merge({}, newPayload, branchResult)) || newPayload\n                }\n              }\n\n              controller.emit('actionEnd', {action: action, signal: signal, options: options, payload: payload})\n              return runBranch(branch, index + 1, start, newPayload) || newPayload\n            }\n          }\n        }\n\n        runBranch(signal.branches, 0, Date.now(), signalPayload)\n\n        return\n      }\n\n      if (signal.isSync) {\n        runSignal()\n      } else {\n        batchedSignals.push(runSignal)\n\n        if (!pending) {\n          requestAnimationFrame(function () {\n            while (batchedSignals.length) {\n              batchedSignals.shift()()\n            }\n            pending = false\n          })\n\n          pending = true\n        }\n      }\n    }\n    signalChain.signalName = signalName\n    Object.defineProperty(signalChain, 'chain', {\n      get: function () {\n        return chain\n      },\n      set: function (value) {\n        console.warn('Cerebral - signal chain property is DEPRECATED. Please describe your usage at https://github.com/cerebral/cerebral/issues/243')\n        chain = value\n      },\n      enumerable: true,\n      configurable: true\n    })\n\n    return signalChain\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/cerebral/src/CreateSignalFactory.js\n ** module id = 132\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/cerebral/src/CreateSignalFactory.js?");

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(global, process) {var types = __webpack_require__(135)\n\nmodule.exports = {\n  getFunctionName: function (fun) {\n    var ret = fun.toString()\n    ret = ret.substr('function '.length)\n    ret = ret.substr(0, ret.indexOf('('))\n    return ret\n  },\n  merge: function () {\n    var args = [].slice.call(arguments)\n    var target = args.shift()\n    return args.reduce(function (target, source) {\n      return Object.keys(source || {}).reduce(function (target, key) {\n        target[key] = source[key]\n        return target\n      }, target)\n    }, target)\n  },\n  hasLocalStorage: function () {\n    return typeof global.localStorage !== 'undefined'\n  },\n  isPathObject: function (obj) {\n    return (\n    obj && (obj.resolve || obj.reject)\n    )\n  },\n  debounce: function debounce (func, wait, immediate) {\n    var timeout\n    return function () {\n      var context = this\n      var args = arguments\n      var later = function () {\n        timeout = null\n        if (!immediate) func.apply(context, args)\n      }\n      var callNow = immediate && !timeout\n      clearTimeout(timeout)\n      timeout = setTimeout(later, wait)\n      if (callNow) func.apply(context, args)\n    }\n  },\n  isAction: function (action) {\n    return typeof action === 'function'\n  },\n  isDeveloping: function () {\n    return typeof process === 'undefined' || (\"production\") !== 'production'\n  },\n  verifyInput: function (actionName, signalName, input, signalArgs) {\n    Object.keys(input).forEach(function (key) {\n      if (typeof signalArgs[key] === 'undefined' || !types(input[key], signalArgs[key])) {\n        throw new Error([\n          'Cerebral: You are giving the wrong input to the action \"' +\n          actionName + '\" ' +\n          'in signal \"' + signalName + '\". Check the following prop: \"' + key + '\"'\n        ].join(''))\n      }\n    })\n  },\n  extractMatchingPathFunctions: function (source, target) {\n    var incompatible = false\n    var traverse = function (obj, currentTarget, path, results) {\n      if (incompatible) {\n        return incompatible\n      }\n\n      if (typeof obj === 'function') {\n        results[path.join('.')] = obj\n      } else if (typeof obj === 'object' && !Array.isArray(obj) && obj !== null) {\n        for (var key in obj) {\n          if (!(key in currentTarget)) {\n            incompatible = path.slice().concat(key)\n            return incompatible\n          } else {\n            path.push(key)\n            traverse(obj[key], currentTarget[key], path, results)\n            path.pop(key)\n          }\n        }\n      }\n      return incompatible || results\n    }\n\n    return traverse(source, target, [], {})\n  },\n  setDeep: function (object, stringPath, value) {\n    var path = stringPath.split('.')\n    var setKey = path.pop()\n    while (path.length) {\n      var key = path.shift()\n      object = object[key] = object[key] || {}\n    }\n    object[setKey] = object[setKey] ? Object.keys(object[setKey]).reduce(function (value, key) {\n      value[key] = object[setKey][key]\n      return value\n    }, value) : value\n    return value\n  },\n  extractExternalContextProviders: function (providers, modulePath) {\n    var extractedProviders = providers.__cerebral_global__\n    if (modulePath && providers[modulePath.join('.')]) {\n      return extractedProviders.concat(providers[modulePath.join('.')])\n    }\n\n    return extractedProviders\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(134)))\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/cerebral/src/utils.js\n ** module id = 133\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/cerebral/src/utils.js?");

/***/ },
/* 134 */,
/* 135 */
/***/ function(module, exports) {

	eval("module.exports = function (type, value) {\n  var types = [\n    String,\n    Number,\n    Array,\n    Object,\n    Boolean\n  ]\n\n  if (type === null && value !== null) {\n    return false\n  }\n\n  if (type === undefined && value !== undefined) {\n    return false\n  }\n\n  if (type === String && typeof value !== 'string') {\n    return false\n  }\n\n  if (type === Number && typeof value !== 'number') {\n    return false\n  }\n\n  if (type === Array && !Array.isArray(value)) {\n    return false\n  }\n\n  if (type === Object && !(typeof value === 'object' && !Array.isArray(value) && value !== null)) {\n    return false\n  }\n\n  if (type === Boolean && typeof value !== 'boolean') {\n    return false\n  }\n\n  if (types.indexOf(type) === -1 && typeof type === 'function') {\n    return type(value)\n  }\n\n  return true\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/cerebral/src/types.js\n ** module id = 135\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/cerebral/src/types.js?");

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	eval("var utils = __webpack_require__(133)\n\nmodule.exports = function (signalName, actions) {\n  var traverse = function (actions, parentActions, parentIndex) {\n    actions.forEach(function (action, index) {\n      var nextPaths\n\n      if (typeof action === 'undefined') {\n        throw new Error([\n          'Cerebral: Action number \"' + index + '\" in signal \"' + signalName +\n          '\" does not exist. Check that you have spelled it correctly!'\n        ].join(''))\n      }\n\n      if (Array.isArray(action)) {\n        traverse(action, actions, index)\n      } else {\n        nextPaths = actions[index + 1]\n\n        if (action.output && (\n          (parentActions && typeof nextPaths === 'function') ||\n          (!parentActions && (typeof nextPaths !== 'function' || !nextPaths)) ||\n          (parentActions && typeof parentActions[parentIndex + 1] !== 'function')\n        )) {\n          throw new Error([\n            'Cerebral: The action \"' + utils.getFunctionName(action) +\n            '\" in signal \"' + signalName + '\" has an output definition, but there is ' +\n            'no action to receive it. ' +\n            (nextPaths ? 'But there are ' + JSON.stringify(Object.keys(nextPaths)) + ' paths, should it be outputs?' : '')\n          ].join(''))\n        } else if (action.outputs && (!nextPaths || typeof nextPaths === 'function')) {\n          throw new Error([\n            'Cerebral: The action \"' + utils.getFunctionName(action) +\n            '\" in signal \"' + signalName + '\" has an output value. ' +\n            'There should be these paths: ' + JSON.stringify(Array.isArray(action.outputs) ? action.outputs : Object.keys(action.outputs))\n          ].join(''))\n        } else if (Array.isArray(action.outputs)) {\n          nextPaths = actions[index + 1]\n\n          action.outputs.forEach(function (output) {\n            if (!Array.isArray(nextPaths[output])) {\n              throw new Error([\n                'Cerebral: The action \"' + utils.getFunctionName(action) +\n                '\" in signal \"' + signalName + '\" can not find path to its \"' +\n                output + '\" output'\n              ].join(''))\n            }\n          })\n        } else if (action.outputs) {\n          Object.keys(action.outputs).forEach(function (output) {\n            if (!Array.isArray(nextPaths[output])) {\n              throw new Error([\n                'Cerebral: The action \"' + utils.getFunctionName(action) +\n                '\" in signal \"' + signalName + '\" can not find path to its \"' +\n                output + '\" output'\n              ].join(''))\n            }\n          })\n        } else if (!Array.isArray(action) && typeof action === 'object' && action !== null) {\n          var prevAction = actions[index - 1]\n          Object.keys(action).forEach(function (key) {\n            if (!Array.isArray(action[key])) {\n              throw new Error([\n                'Cerebral: The paths for action \"' + utils.getFunctionName(prevAction) +\n                '\" in signal \"' + signalName + '\" are not valid. They have to be an array\"'\n              ].join(''))\n            }\n          })\n        }\n      }\n    })\n  }\n  traverse(actions)\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/cerebral/src/analyze.js\n ** module id = 136\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/cerebral/src/analyze.js?");

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	eval("var utils = __webpack_require__(133)\n\nvar traverse = function (item, parentItem, path, actions, isSync) {\n  var nextItem\n  var returnAsync = function (item) {\n    isSync = !isSync\n    return item.map(function (subItem, index) {\n      path.push(index)\n      var result = traverse(subItem, item, path, actions, isSync)\n      path.pop()\n      return result\n    }).filter(function (action) { // Objects becomes null\n      return !!action\n    })\n  }\n\n  if (typeof item === 'function' && item.async && isSync) {\n    nextItem = parentItem[parentItem.indexOf(item) + 1]\n    if (!Array.isArray(nextItem) && typeof nextItem === 'object') {\n      parentItem.splice(parentItem.indexOf(nextItem), 1)\n      return returnAsync([item, nextItem])\n    } else {\n      return returnAsync([item])\n    }\n  } else if (Array.isArray(item)) {\n    item = item.slice() // Will do some splicing, so make sure not messing up original array\n    return returnAsync(item)\n  } else if (typeof item === 'function') {\n    var action = {\n      name: item.displayName || utils.getFunctionName(item),\n      options: {\n        output: item.output,\n        outputs: item.outputs,\n        defaultOutput: item.defaultOutput,\n        defaultInput: item.defaultInput,\n        input: item.input\n      },\n      duration: 0,\n      isAsync: !isSync,\n      isExecuting: false,\n      hasExecuted: false,\n      path: path.slice(),\n      outputs: null,\n      actionIndex: actions.indexOf(item) === -1 ? actions.push(item) - 1 : actions.indexOf(item)\n    }\n    nextItem = parentItem[parentItem.indexOf(item) + 1]\n    if (!Array.isArray(nextItem) && typeof nextItem === 'object') {\n      parentItem.splice(parentItem.indexOf(nextItem), 1)\n      action.outputs = Object.keys(nextItem).reduce(function (paths, key) {\n        if (Array.isArray(item.outputs) && !~item.outputs.indexOf(key)) {\n          throw new Error('Cerebral - output path ' + key + ' doesn\\'t matches to possible otputs defined for ' + action.name + ' action')\n        }\n        path = path.concat('outputs', key)\n        paths[key] = traverse(nextItem[key], parentItem, path, actions, false)\n        path.pop()\n        path.pop()\n        return paths\n      }, {})\n    }\n    return action\n  }\n}\n\nmodule.exports = function (signals) {\n  var actions = []\n  var branches = traverse(signals, [], [], actions, false)\n  return {\n    branches: branches,\n    actions: actions\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/cerebral/src/staticTree.js\n ** module id = 137\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/cerebral/src/staticTree.js?");

/***/ },
/* 138 */
/***/ function(module, exports) {

	eval("module.exports = function (contextProviders, execution, controller) {\n  contextProviders = contextProviders.reduce(function (uniqueContextProviders, contextProvider) {\n    if (uniqueContextProviders.indexOf(contextProvider) === -1) {\n      return uniqueContextProviders.concat(contextProvider)\n    }\n    return uniqueContextProviders\n  }, [])\n  return contextProviders.reduce(function (context, contextProvider) {\n    if (typeof contextProvider === 'function') {\n      return contextProvider(context, execution, controller)\n    } else {\n      return Object.keys(contextProvider).reduce(function (context, key) {\n        context[key] = contextProvider[key]\n\n        return context\n      }, context)\n    }\n  }, {})\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/cerebral/src/createContext.js\n ** module id = 138\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/cerebral/src/createContext.js?");

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	eval("var utils = __webpack_require__(133)\n\nmodule.exports = function (context, execution) {\n  var action = execution.action\n  var signal = execution.signal\n  var inputs = [\n    {},\n    execution.payload,\n    action.options.defaultInput ? action.options.defaultInput : {}\n  ]\n  context.input = utils.merge.apply(null, inputs)\n\n  if (utils.isDeveloping() && action.options.input) {\n    utils.verifyInput(action.name, signal.name, action.options.input, context.input)\n    try {\n      JSON.stringify(context.input)\n    } catch (e) {\n      console.log('Not serializable', context.input)\n      throw new Error('Cerebral - Could not serialize input to signal. Please check signal ' + signal.name)\n    }\n  }\n\n  return context\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/cerebral/providers/inputProvider.js\n ** module id = 139\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/cerebral/providers/inputProvider.js?");

/***/ },
/* 140 */
/***/ function(module, exports) {

	eval("module.exports = function (context, execution, controller) {\n  var action = execution.action\n  var model = controller.getModel()\n  var isAsync = action.isAsync\n\n  var createStateObject = function (parentPath) {\n    var state = Object.keys(model.accessors || {}).reduce(function (state, accessor) {\n      state[accessor] = function () {\n        var args = [].slice.call(arguments)\n        var path = []\n        if (args[0] && Array.isArray(args[0])) {\n          path = args.shift()\n        } else if (args[0] && typeof args[0] === 'string') {\n          path = args.shift().split('.')\n        }\n        if (accessor === 'get' && typeof arguments[0] === 'function') {\n          return controller.get(arguments[0])\n        }\n        return model.accessors[accessor].apply(null, [parentPath.concat(path)].concat(args))\n      }\n      return state\n    }, {})\n    Object.keys(model.mutators || {}).reduce(function (state, mutator) {\n      state[mutator] = function () {\n        if (isAsync) {\n          throw new Error('Cerebral: You can not mutate state in async actions. Output values and set them with a sync action')\n        }\n        var path = []\n        var args = [].slice.call(arguments)\n        if (Array.isArray(args[0])) {\n          path = args.shift()\n        } else if (typeof args[0] === 'string') {\n          path = args.shift().split('.')\n        }\n\n        return model.mutators[mutator].apply(null, [parentPath.concat(path)].concat(args))\n      }\n      return state\n    }, state)\n\n    state.select = function (path) {\n      return createStateObject(typeof path === 'string' ? path.split('.') : path)\n    }\n\n    state.computed = function (computed) {\n      return computed.get(model.accessors.get([]))\n    }\n\n    return state\n  }\n\n  context.state = createStateObject([])\n\n  return context\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/cerebral/providers/stateProvider.js\n ** module id = 140\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/cerebral/providers/stateProvider.js?");

/***/ },
/* 141 */
/***/ function(module, exports) {

	eval("module.exports = function (context, execution, controller) {\n  context.services = controller.getServices()\n\n  return context\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/cerebral/providers/servicesProvider.js\n ** module id = 141\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/cerebral/providers/servicesProvider.js?");

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	eval("var utils = __webpack_require__(133)\nvar types = __webpack_require__(135)\n\nvar validateOutput = function (action, path, arg, signalName) {\n  if ((!action.options.output && !action.options.outputs) || Array.isArray(action.options.outputs)) {\n    return\n  }\n\n  var checkers = action.options.output || action.options.outputs[path || action.options.defaultOutput]\n\n  if (checkers === undefined) {\n    return\n  }\n\n  if (!arg) {\n    throw new Error([\n      'Cerebral: There is a wrong output of action \"' +\n      utils.getFunctionName(action) + '\" ' +\n      'in signal \"' + signalName + '\". You did not pass any values to the output'\n    ].join(''))\n  }\n\n  Object.keys(checkers).forEach(function (key) {\n    if (!types(checkers[key], arg[key])) {\n      throw new Error([\n        'Cerebral: There is a wrong output of action \"' +\n        utils.getFunctionName(action) + '\" ' +\n        'in signal \"' + signalName + '\". Check the following prop: \"' + key + '\"'\n      ].join(''))\n    }\n  })\n}\n\nvar createNextFunction = function (action, signalName, resolver) {\n  var next = function () {\n    if (next.hasRun) {\n      throw new Error('Cerebral - You are running an async output on a synchronous action in ' + signalName + '. The action is ' + action.name + '. Either put it in an array or make sure the output is synchronous')\n    }\n\n    var path = typeof arguments[0] === 'string' ? arguments[0] : null\n    var payload = path ? arguments[1] : arguments[0]\n\n    // Test payload\n    if (utils.isDeveloping()) {\n      try {\n        JSON.stringify(payload)\n      } catch (e) {\n        console.log('Not serializable', payload)\n        throw new Error('Cerebral - Could not serialize output. Please check signal ' + signalName + ' and action ' + action.name)\n      }\n    }\n\n    if (!path && !action.options.defaultOutput && action.options.outputs) {\n      throw new Error([\n        'Cerebral: There is a wrong output of action \"' +\n        utils.getFunctionName(action) + '\" ' +\n        'in signal \"' + signalName + '\". Set defaultOutput or use one of outputs ' +\n        JSON.stringify(Object.keys(action.output || action.outputs || {}))\n      ].join(''))\n    }\n\n    if (utils.isDeveloping()) {\n      validateOutput(action, path, payload, signalName)\n    }\n\n    // This is where I verify path and types\n    var result = {\n      path: path || action.options.defaultOutput,\n      payload: payload || {}\n    }\n    resolver(result)\n  }\n  return next\n}\n\nmodule.exports = function (context, execution) {\n  var action = execution.action\n  var signalName = execution.signal.name\n  var resolve = execution.resolve\n  var next = createNextFunction(action, signalName, resolve)\n  if (action.outputs) {\n    Object.keys(action.outputs).forEach(function (key) {\n      next[key] = next.bind(null, key)\n    })\n  }\n\n  if (!resolve && utils.isDeveloping()) {\n    setTimeout(function () {\n      next.hasRun = true\n    }, 0)\n  }\n  context.output = next\n\n  return context\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/cerebral/providers/outputProvider.js\n ** module id = 142\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/cerebral/providers/outputProvider.js?");

/***/ },
/* 143 */
/***/ function(module, exports) {

	eval("module.exports = function (context, execution, controller) {\n  if (!context.module && !context.modules) {\n    Object.defineProperty(context, 'module', {\n      get: function () {\n        throw new Error('DEPRECATED: Use of \"module\" in signal \"' + execution.signal.name + '\" and action \"' + execution.action.name + '\" is no longer supported. Please install: https://github.com/cerebral/cerebral-provider-modules to get some more juice!')\n      }\n    })\n\n    Object.defineProperty(context, 'modules', {\n      get: function () {\n        throw new Error('DEPRECATED: Use of \"modules\" in signal \"' + execution.signal.name + '\" and action \"' + execution.action.name + '\" is no longer supported. Please install: https://github.com/cerebral/cerebral-provider-modules to get some more juice!')\n      }\n    })\n  }\n\n  return context\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/cerebral/providers/deprecationProvider.js\n ** module id = 143\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/cerebral/providers/deprecationProvider.js?");

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	eval("var utils = __webpack_require__(133)\n\nmodule.exports = function (controller, model, allModules) {\n  var initialState = {}\n\n  var registerSignals = function (moduleName, signals) {\n    var scopedSignals = Object.keys(signals).reduce(function (scopedSignals, key) {\n      scopedSignals[moduleName + '.' + key] = signals[key]\n      return scopedSignals\n    }, {})\n\n    return controller.addSignals(scopedSignals, {\n      modulePath: moduleName.split('.')\n    })\n  }\n\n  var registerServices = function (moduleName, services) {\n    var scopedServices = Object.keys(services).reduce(function (scopedServices, key) {\n      scopedServices[moduleName + '.' + key] = services[key]\n      return scopedServices\n    }, {})\n    controller.addServices(scopedServices)\n  }\n\n  var registerInitialState = function (moduleName, state) {\n    utils.setDeep(initialState, moduleName, state)\n    model.mutators.set(moduleName.split('.'), state)\n  }\n\n  var registerModules = function (parentModuleName, modules) {\n    var warnSignalTrigger = null\n    if (arguments.length === 1) {\n      modules = parentModuleName\n      parentModuleName = null\n      warnSignalTrigger = function (event) {\n        throw new Error('Cerebral - You triggered a signal ' + event.signal.name + ' while modules are being registered. Do not trigger signals until Cerebral has initialized your application.')\n      }\n      controller.on('signalTrigger', warnSignalTrigger)\n    }\n\n    Object.keys(modules).forEach(function (moduleName) {\n      registerModule(moduleName, parentModuleName, modules)\n    })\n\n    if (arguments.length === 1) {\n      controller.removeListener('signalTrigger', warnSignalTrigger)\n      controller.emit('modulesLoaded', { modules: allModules })\n    }\n\n    return allModules\n  }\n\n  var registerModule = function (moduleName, parentModuleName, modules) {\n    var moduleConstructor = modules[moduleName]\n    var actualName = moduleName\n    if (parentModuleName) {\n      moduleName = parentModuleName + '.' + moduleName\n    }\n    var moduleExport = {\n      name: actualName,\n      path: moduleName.split('.')\n    }\n    var module = {\n      name: moduleName,\n      path: moduleExport.path.slice(),\n      alias: function (alias) {\n        allModules[alias] = moduleExport\n      },\n      addSignals: registerSignals.bind(null, moduleName),\n      addServices: registerServices.bind(null, moduleName),\n      addState: registerInitialState.bind(null, moduleName),\n      getSignals: function () {\n        var signals = controller.getSignals()\n        var path = moduleName.split('.')\n        return path.reduce(function (signals, key) {\n          return signals[key]\n        }, signals)\n      },\n      addModules: registerModules.bind(null, moduleName),\n      addContextProvider: function (provider) {\n        controller.addContextProvider(provider, moduleName)\n      }\n    }\n    var constructedModule = moduleConstructor(module, controller)\n\n    moduleExport.meta = constructedModule\n    module.meta = constructedModule\n    allModules[moduleName] = moduleExport\n\n    return moduleExport\n  }\n\n  controller.on('reset', function () {\n    model.mutators.merge([], initialState)\n  })\n\n  return registerModules\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/cerebral/src/CreateRegisterModules.js\n ** module id = 144\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/cerebral/src/CreateRegisterModules.js?");

/***/ },
/* 145 */,
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	eval("function getByPath (path, state) {\n  var currentPath = state\n  for (var x = 0; x < path.length; x++) {\n    var key = path[x]\n    if (currentPath[key] === undefined) {\n      return currentPath[key]\n    }\n    currentPath = currentPath[key]\n  }\n  return currentPath\n}\n\nfunction cleanPath (path) {\n  if (Array.isArray(path)) {\n    path = path.join('.')\n  }\n\n  return path.replace(/\\.\\*\\*|\\.\\*/, '')\n}\n\nfunction traverseDepsMap (deps, cacheKey) {\n  Object.keys(deps).forEach(function (key) {\n    var depsKey = deps[key].getDepsMap ? deps[key] : cleanPath(deps[key])\n    if (depsKey.getDepsMap) {\n      traverseDepsMap(depsKey.getDepsMap(), cacheKey)\n    } else if (!Computed.registry[depsKey]) {\n      Computed.registry[depsKey] = [cacheKey]\n    } else if (Computed.registry[depsKey].indexOf(cacheKey) === -1) {\n      Computed.registry[depsKey] = Computed.registry[depsKey].concat(cacheKey)\n    }\n  })\n}\n\nfunction Computed (paths, cb) {\n  return function (props) {\n    var deps = typeof paths === 'function' ? paths(props) : paths\n    var cacheKey = JSON.stringify(deps) + (props ? JSON.stringify(props) : '') + cb.toString().replace(/\\s/g, '')\n    traverseDepsMap(deps, cacheKey)\n\n    return {\n      getDepsMap: function () {\n        return deps\n      },\n      get: function (passedState) {\n        if (Computed.cache[cacheKey]) {\n          return Computed.cache[cacheKey]\n        }\n\n        var depsProps = Object.keys(deps).reduce(function (props, key) {\n          if (typeof deps[key] === 'string' || Array.isArray(deps[key])) {\n            var path = cleanPath(deps[key])\n            props[key] = getByPath(path.split('.'), passedState)\n          } else {\n            props[key] = deps[key].get(passedState)\n          }\n          return props\n        }, {})\n        var passedProps = props || {}\n        var allProps = Object.keys(passedProps).reduce(function (depsProps, key) {\n          depsProps[key] = passedProps[key]\n          return depsProps\n        }, depsProps)\n        var value = cb(allProps)\n        Computed.cache[cacheKey] = value\n        return value\n      }\n    }\n  }\n}\n\nComputed.cache = {}\nComputed.registry = {}\nComputed.updateCache = function (changes) {\n  var computedMap = Computed.registry\n  function traverse (level, currentPath, computedToFlag) {\n    Object.keys(level).forEach(function (key) {\n      currentPath.push(key)\n      var stringPath = currentPath.join('.')\n      if (computedMap[stringPath]) {\n        computedToFlag = computedMap[stringPath].reduce(function (computedToFlag, computed) {\n          if (computedToFlag.indexOf(computed) === -1) {\n            return computedToFlag.concat(computed)\n          }\n          return computedToFlag\n        }, computedToFlag)\n      }\n      if (level[key] !== true) {\n        computedToFlag = traverse(level[key], currentPath, computedToFlag)\n      }\n      currentPath.pop()\n    })\n    return computedToFlag\n  }\n  var computedToFlag = traverse(changes, [], [])\n  computedToFlag.forEach(function (computed) {\n    delete Computed.cache[computed]\n  })\n}\n\nif (false) {\n  var testComputed = function Computed (paths, cb) { return cb }\n  testComputed.updateCache = Computed.updateCache\n  module.exports = testComputed\n} else {\n  module.exports = Computed\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/cerebral/src/Computed.js\n ** module id = 146\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/cerebral/src/Computed.js?");

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	eval("var Baobab = __webpack_require__(148);\nfunction deepmerge(target, src) {\n   var array = Array.isArray(src);\n   var dst = array && [] || {};\n\n   if (array) {\n       target = target || [];\n       dst = src.slice();\n       src.forEach(function(e, i) {\n           if (typeof dst[i] === 'undefined') {\n               dst[i] = e;\n           } else if (typeof e === 'object') {\n               dst[i] = deepmerge(target[i], e);\n           }\n       });\n   } else {\n       if (target && typeof target === 'object') {\n           Object.keys(target).forEach(function (key) {\n               dst[key] = target[key];\n           })\n       }\n       Object.keys(src).forEach(function (key) {\n           if (typeof src[key] !== 'object' || !src[key]) {\n               dst[key] = src[key];\n           }\n           else {\n               if (!target[key]) {\n                   dst[key] = src[key];\n               } else {\n                   dst[key] = deepmerge(target[key], src[key]);\n               }\n           }\n       });\n   }\n\n   return dst;\n};\n\nfunction createForcedChange(state, changes) {\n  function traverse(currentPath, path, currentChangePath) {\n    if (\n      !Array.isArray(currentPath) &&\n      typeof currentPath === 'object' &&\n      currentPath !== null &&\n      Object.keys(currentPath).length\n    ) {\n      Object.keys(currentPath).forEach(function (key) {\n        path.push(key)\n        currentChangePath[key] = traverse(currentPath[key], path, {})\n        path.pop()\n      })\n      return currentChangePath\n    }\n    return true\n  }\n  traverse(state, [], changes)\n  return changes\n}\n\nvar Model = function (initialState, options) {\n\n  options = options || {};\n\n  var tree = new Baobab(initialState, options);\n\n  function update(changes, path) {\n    path.reduce(function (changes, key, index) {\n      if (index === path.length - 1 && !changes[key]) {\n        changes[key] = true\n      } else if (changes[key] === true) {\n        changes[key] = {}\n      } else if (!changes[key]) {\n        changes[key] = {}\n      }\n\n      return changes[key];\n    }, changes);\n    return changes;\n  }\n\n  var model = function (controller) {\n\n    controller.on('modulesLoaded', function () {\n      initialState = tree.toJSON()\n    })\n\n    function onUpdate(event) {\n      var changes = event.data.paths.reduce(update, {})\n      controller.emit('flush', changes);\n    }\n\n    controller.on('change', function () {\n      tree.off('update', onUpdate);\n      tree.once('update', onUpdate);\n      tree.commit();\n    });\n\n    controller.on('reset', function () {\n      tree.set(initialState)\n      tree.commit();\n      var forcedChanges = createForcedChange(initialState, {})\n      controller.emit('flush', forcedChanges)\n    });\n\n    controller.on('seek', function (seek, recording) {\n      recording.initialState.forEach(function (state) {\n        tree.set(state.path, state.value)\n      });\n      tree.commit();\n      var forcedChanges = createForcedChange(tree.get(), {})\n      controller.emit('flush', forcedChanges)\n    });\n\n    return {\n        tree: tree,\n        logModel: function () {\n          return tree.get();\n        },\n        accessors: {\n          get: function (path) {\n            return tree.get(path);\n          },\n          toJSON: function () {\n            return tree.toJSON();\n          },\n          toJS: function (path) {\n            return tree.get(path);\n          },\n          serialize: function (path) {\n            return tree.serialize(path);\n          },\n          export: function () {\n            return tree.serialize();\n          },\n          keys: function (path) {\n            return Object.keys(tree.get(path));\n          },\n          findWhere: function (path, obj) {\n            var keysCount = Object.keys(obj).length;\n            return tree.get(path).filter(function (item) {\n              return Object.keys(item).filter(function (key) {\n                return key in obj && obj[key] === item[key];\n              }).length === keysCount;\n            }).pop();\n          }\n        },\n        mutators: {\n          set: function (path, value) {\n            tree.set(path, value);\n          },\n          import: function (newState) {\n            var newState = deepmerge(initialState, newState);\n            tree.set(newState);\n          },\n          unset: function (path, keys) {\n            if (keys) {\n              keys.forEach(function (key) {\n                tree.unset(path.concat(key));\n              })\n            } else {\n              tree.unset(path);\n            }\n          },\n          push: function (path, value) {\n            tree.push(path, value);\n          },\n          splice: function () {\n            var args = [].slice.call(arguments);\n            tree.splice.call(tree, args.shift(), args);\n          },\n          merge: function (path, value) {\n            tree.merge(path, value);\n          },\n          concat: function (path, value) {\n            tree.apply(path, function (existingValue) {\n              return existingValue.concat(value);\n            });\n          },\n          pop: function (path) {\n            var val;\n            tree.apply(path, function (existingValue) {\n              var copy = existingValue.slice();\n              val = copy.pop();\n              return copy;\n            });\n            return val;\n          },\n          shift: function (path) {\n            var val;\n            tree.apply(path, function (existingValue) {\n              var copy = existingValue.slice();\n              val = copy.shift();\n              return copy;\n            });\n            return val;\n          },\n          unshift: function (path, value) {\n            tree.unshift(path, value);\n          }\n        }\n    };\n\n  };\n\n  model.tree = tree;\n\n  return model;\n\n};\n\nModel.monkey = Baobab.monkey;\nModel.dynamicNode = Baobab.dynamicNode;\n\nmodule.exports = Model;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/cerebral-model-immutable/index.js\n ** module id = 147\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/cerebral-model-immutable/index.js?");

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Baobab Data Structure\n * ======================\n *\n * A handy data tree with cursors.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _emmett = __webpack_require__(149);\n\nvar _emmett2 = _interopRequireDefault(_emmett);\n\nvar _cursor = __webpack_require__(150);\n\nvar _cursor2 = _interopRequireDefault(_cursor);\n\nvar _monkey = __webpack_require__(151);\n\nvar _watcher = __webpack_require__(155);\n\nvar _watcher2 = _interopRequireDefault(_watcher);\n\nvar _type = __webpack_require__(152);\n\nvar _type2 = _interopRequireDefault(_type);\n\nvar _update2 = __webpack_require__(153);\n\nvar _update3 = _interopRequireDefault(_update2);\n\nvar _helpers = __webpack_require__(154);\n\nvar helpers = _interopRequireWildcard(_helpers);\n\nvar arrayFrom = helpers.arrayFrom;\nvar coercePath = helpers.coercePath;\nvar deepFreeze = helpers.deepFreeze;\nvar getIn = helpers.getIn;\nvar makeError = helpers.makeError;\nvar deepClone = helpers.deepClone;\nvar deepMerge = helpers.deepMerge;\nvar shallowClone = helpers.shallowClone;\nvar shallowMerge = helpers.shallowMerge;\nvar uniqid = helpers.uniqid;\n\n/**\n * Baobab defaults\n */\nvar DEFAULTS = {\n\n  // Should the tree handle its transactions on its own?\n  autoCommit: true,\n\n  // Should the transactions be handled asynchronously?\n  asynchronous: true,\n\n  // Should the tree's data be immutable?\n  immutable: true,\n\n  // Should the monkeys be lazy?\n  lazyMonkeys: true,\n\n  // Should the tree be persistent?\n  persistent: true,\n\n  // Should the tree's update be pure?\n  pure: true,\n\n  // Validation specifications\n  validate: null,\n\n  // Validation behavior 'rollback' or 'notify'\n  validationBehavior: 'rollback'\n};\n\n/**\n * Function returning a string hash from a non-dynamic path expressed as an\n * array.\n *\n * @param  {array}  path - The path to hash.\n * @return {string} string - The resultant hash.\n */\nfunction hashPath(path) {\n  return 'λ' + path.map(function (step) {\n    if (_type2['default']['function'](step) || _type2['default'].object(step)) return '#' + uniqid() + '#';\n\n    return step;\n  }).join('λ');\n}\n\n/**\n * Baobab class\n *\n * @constructor\n * @param {object|array} [initialData={}]    - Initial data passed to the tree.\n * @param {object}       [opts]              - Optional options.\n * @param {boolean}      [opts.autoCommit]   - Should the tree auto-commit?\n * @param {boolean}      [opts.asynchronous] - Should the tree's transactions\n *                                             handled asynchronously?\n * @param {boolean}      [opts.immutable]    - Should the tree be immutable?\n * @param {boolean}      [opts.persistent]   - Should the tree be persistent?\n * @param {boolean}      [opts.pure]         - Should the tree be pure?\n * @param {function}     [opts.validate]     - Validation function.\n * @param {string}       [opts.validationBehaviour] - \"rollback\" or \"notify\".\n */\n\nvar Baobab = (function (_Emitter) {\n  _inherits(Baobab, _Emitter);\n\n  function Baobab(initialData, opts) {\n    var _this = this;\n\n    _classCallCheck(this, Baobab);\n\n    _get(Object.getPrototypeOf(Baobab.prototype), 'constructor', this).call(this);\n\n    // Setting initialData to an empty object if no data is provided by use\n    if (arguments.length < 1) initialData = {};\n\n    // Checking whether given initial data is valid\n    if (!_type2['default'].object(initialData) && !_type2['default'].array(initialData)) throw makeError('Baobab: invalid data.', { data: initialData });\n\n    // Merging given options with defaults\n    this.options = shallowMerge({}, DEFAULTS, opts);\n\n    // Disabling immutability & persistence if persistence if disabled\n    if (!this.options.persistent) {\n      this.options.immutable = false;\n      this.options.pure = false;\n    }\n\n    // Privates\n    this._identity = '[object Baobab]';\n    this._cursors = {};\n    this._future = null;\n    this._transaction = [];\n    this._affectedPathsIndex = {};\n    this._monkeys = {};\n    this._previousData = null;\n    this._data = initialData;\n\n    // Properties\n    this.root = new _cursor2['default'](this, [], 'λ');\n    delete this.root.release;\n\n    // Does the user want an immutable tree?\n    if (this.options.immutable) deepFreeze(this._data);\n\n    // Bootstrapping root cursor's getters and setters\n    var bootstrap = function bootstrap(name) {\n      _this[name] = function () {\n        var r = this.root[name].apply(this.root, arguments);\n        return r instanceof _cursor2['default'] ? this : r;\n      };\n    };\n\n    ['apply', 'clone', 'concat', 'deepClone', 'deepMerge', 'exists', 'get', 'push', 'merge', 'pop', 'project', 'serialize', 'set', 'shift', 'splice', 'unset', 'unshift'].forEach(bootstrap);\n\n    // Registering the initial monkeys\n    this._refreshMonkeys();\n\n    // Initial validation\n    var validationError = this.validate();\n\n    if (validationError) throw Error('Baobab: invalid data.', { error: validationError });\n  }\n\n  /**\n   * Monkey helper.\n   */\n\n  /**\n   * Internal method used to refresh the tree's monkey register on every\n   * update.\n   * Note 1) For the time being, placing monkeys beneath array nodes is not\n   * allowed for performance reasons.\n   *\n   * @param  {mixed}   node      - The starting node.\n   * @param  {array}   path      - The starting node's path.\n   * @param  {string}  operation - The operation that lead to a refreshment.\n   * @return {Baobab}            - The tree instance for chaining purposes.\n   */\n\n  _createClass(Baobab, [{\n    key: '_refreshMonkeys',\n    value: function _refreshMonkeys(node, path, operation) {\n      var _this2 = this;\n\n      var clean = function clean(data) {\n        var p = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\n        if (data instanceof _monkey.Monkey) {\n          data.release();\n          (0, _update3['default'])(_this2._monkeys, p, { type: 'unset' }, {\n            immutable: false,\n            persistent: false,\n            pure: false\n          });\n\n          return;\n        }\n\n        if (_type2['default'].object(data)) {\n          for (var k in data) {\n            clean(data[k], p.concat(k));\n          }\n        }\n      };\n\n      var walk = function walk(data) {\n        var p = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\n        // Should we sit a monkey in the tree?\n        if (data instanceof _monkey.MonkeyDefinition || data instanceof _monkey.Monkey) {\n          var monkeyInstance = new _monkey.Monkey(_this2, p, data instanceof _monkey.Monkey ? data.definition : data);\n\n          (0, _update3['default'])(_this2._monkeys, p, { type: 'set', value: monkeyInstance }, {\n            immutable: false,\n            persistent: false,\n            pure: false\n          });\n\n          return;\n        }\n\n        // Object iteration\n        if (_type2['default'].object(data)) {\n          for (var k in data) {\n            walk(data[k], p.concat(k));\n          }\n        }\n      };\n\n      // Walking the whole tree\n      if (!arguments.length) {\n        walk(this._data);\n      } else {\n        var monkeysNode = getIn(this._monkeys, path).data;\n\n        // Is this required that we clean some already existing monkeys?\n        if (monkeysNode) clean(monkeysNode, path);\n\n        // Let's walk the tree only from the updated point\n        if (operation !== 'unset') {\n          walk(node, path);\n        }\n      }\n\n      return this;\n    }\n\n    /**\n     * Method used to validate the tree's data.\n     *\n     * @return {boolean} - Is the tree valid?\n     */\n  }, {\n    key: 'validate',\n    value: function validate(affectedPaths) {\n      var _options = this.options;\n      var validate = _options.validate;\n      var behavior = _options.validationBehavior;\n\n      if (typeof validate !== 'function') return null;\n\n      var error = validate.call(this, this._previousData, this._data, affectedPaths || [[]]);\n\n      if (error instanceof Error) {\n\n        if (behavior === 'rollback') {\n          this._data = this._previousData;\n          this._affectedPathsIndex = {};\n          this._transaction = [];\n          this._previousData = this._data;\n        }\n\n        this.emit('invalid', { error: error });\n\n        return error;\n      }\n\n      return null;\n    }\n\n    /**\n     * Method used to select data within the tree by creating a cursor. Cursors\n     * are kept as singletons by the tree for performance and hygiene reasons.\n     *\n     * Arity (1):\n     * @param {path}    path - Path to select in the tree.\n     *\n     * Arity (*):\n     * @param {...step} path - Path to select in the tree.\n     *\n     * @return {Cursor}      - The resultant cursor.\n     */\n  }, {\n    key: 'select',\n    value: function select(path) {\n\n      // If no path is given, we simply return the root\n      path = path || [];\n\n      // Variadic\n      if (arguments.length > 1) path = arrayFrom(arguments);\n\n      // Checking that given path is valid\n      if (!_type2['default'].path(path)) throw makeError('Baobab.select: invalid path.', { path: path });\n\n      // Casting to array\n      path = [].concat(path);\n\n      // Computing hash (done here because it would be too late to do it in the\n      // cursor's constructor since we need to hit the cursors' index first).\n      var hash = hashPath(path);\n\n      // Creating a new cursor or returning the already existing one for the\n      // requested path.\n      var cursor = this._cursors[hash];\n\n      if (!cursor) {\n        cursor = new _cursor2['default'](this, path, hash);\n        this._cursors[hash] = cursor;\n      }\n\n      // Emitting an event to notify that a part of the tree was selected\n      this.emit('select', { path: path, cursor: cursor });\n      return cursor;\n    }\n\n    /**\n     * Method used to update the tree. Updates are simply expressed by a path,\n     * dynamic or not, and an operation.\n     *\n     * This is where path solving should happen and not in the cursor.\n     *\n     * @param  {path}   path      - The path where we'll apply the operation.\n     * @param  {object} operation - The operation to apply.\n     * @return {mixed} - Return the result of the update.\n     */\n  }, {\n    key: 'update',\n    value: function update(path, operation) {\n      var _this3 = this;\n\n      // Coercing path\n      path = coercePath(path);\n\n      if (!_type2['default'].operationType(operation.type)) throw makeError('Baobab.update: unknown operation type \"' + operation.type + '\".', { operation: operation });\n\n      // Solving the given path\n\n      var _getIn = getIn(this._data, path);\n\n      var solvedPath = _getIn.solvedPath;\n      var exists = _getIn.exists;\n\n      // If we couldn't solve the path, we throw\n      if (!solvedPath) throw makeError('Baobab.update: could not solve the given path.', {\n        path: solvedPath\n      });\n\n      // Read-only path?\n      var monkeyPath = _type2['default'].monkeyPath(this._monkeys, solvedPath);\n      if (monkeyPath && solvedPath.length > monkeyPath.length) throw makeError('Baobab.update: attempting to update a read-only path.', {\n        path: solvedPath\n      });\n\n      // We don't unset irrelevant paths\n      if (operation.type === 'unset' && !exists) return;\n\n      // If we merge data, we need to acknowledge monkeys\n      var realOperation = operation;\n      if (/merge/i.test(operation.type)) {\n        var monkeysNode = getIn(this._monkeys, solvedPath).data;\n\n        if (_type2['default'].object(monkeysNode)) {\n\n          // Cloning the operation not to create weird behavior for the user\n          realOperation = shallowClone(realOperation);\n\n          // Fetching the existing node in the current data\n          var currentNode = getIn(this._data, solvedPath).data;\n\n          if (/deep/i.test(realOperation.type)) realOperation.value = deepMerge({}, deepMerge({}, currentNode, deepClone(monkeysNode)), realOperation.value);else realOperation.value = shallowMerge({}, deepMerge({}, currentNode, deepClone(monkeysNode)), realOperation.value);\n        }\n      }\n\n      // Stashing previous data if this is the frame's first update\n      if (!this._transaction.length) this._previousData = this._data;\n\n      // Applying the operation\n      var result = (0, _update3['default'])(this._data, solvedPath, realOperation, this.options);\n\n      var data = result.data;\n      var node = result.node;\n\n      // If because of purity, the update was moot, we stop here\n      if (!('data' in result)) return node;\n\n      // If the operation is push, the affected path is slightly different\n      var affectedPath = solvedPath.concat(operation.type === 'push' ? node.length - 1 : []);\n\n      var hash = hashPath(affectedPath);\n\n      // Updating data and transaction\n      this._data = data;\n      this._affectedPathsIndex[hash] = true;\n      this._transaction.push(shallowMerge({}, operation, { path: affectedPath }));\n\n      // Updating the monkeys\n      this._refreshMonkeys(node, solvedPath, operation.type);\n\n      // Emitting a `write` event\n      this.emit('write', { path: affectedPath });\n\n      // Should we let the user commit?\n      if (!this.options.autoCommit) return node;\n\n      // Should we update asynchronously?\n      if (!this.options.asynchronous) {\n        this.commit();\n        return node;\n      }\n\n      // Updating asynchronously\n      if (!this._future) this._future = setTimeout(function () {\n        return _this3.commit();\n      }, 0);\n\n      // Finally returning the affected node\n      return node;\n    }\n\n    /**\n     * Method committing the updates of the tree and firing the tree's events.\n     *\n     * @return {Baobab} - The tree instance for chaining purposes.\n     */\n  }, {\n    key: 'commit',\n    value: function commit() {\n\n      // Do not fire update if the transaction is empty\n      if (!this._transaction.length) return this;\n\n      // Clearing timeout if one was defined\n      if (this._future) this._future = clearTimeout(this._future);\n\n      var affectedPaths = Object.keys(this._affectedPathsIndex).map(function (h) {\n        return h !== 'λ' ? h.split('λ').slice(1) : [];\n      });\n\n      // Is the tree still valid?\n      var validationError = this.validate(affectedPaths);\n\n      if (validationError) return this;\n\n      // Caching to keep original references before we change them\n      var transaction = this._transaction,\n          previousData = this._previousData;\n\n      this._affectedPathsIndex = {};\n      this._transaction = [];\n      this._previousData = this._data;\n\n      // Emitting update event\n      this.emit('update', {\n        paths: affectedPaths,\n        currentData: this._data,\n        transaction: transaction,\n        previousData: previousData\n      });\n\n      return this;\n    }\n\n    /**\n     * Method returning a monkey at the given path or else `null`.\n     *\n     * @param  {path}        path - Path of the monkey to retrieve.\n     * @return {Monkey|null}      - The Monkey instance of `null`.\n     */\n  }, {\n    key: 'getMonkey',\n    value: function getMonkey(path) {\n      path = coercePath(path);\n\n      var monkey = getIn(this._monkeys, [].concat(path)).data;\n\n      if (monkey instanceof _monkey.Monkey) return monkey;\n\n      return null;\n    }\n\n    /**\n     * Method used to watch a collection of paths within the tree. Very useful\n     * to bind UI components and such to the tree.\n     *\n     * @param  {object} mapping - Mapping of paths to listen.\n     * @return {Cursor}         - The created watcher.\n     */\n  }, {\n    key: 'watch',\n    value: function watch(mapping) {\n      return new _watcher2['default'](this, mapping);\n    }\n\n    /**\n     * Method releasing the tree and its attached data from memory.\n     */\n  }, {\n    key: 'release',\n    value: function release() {\n      var k = undefined;\n\n      this.emit('release');\n\n      delete this.root;\n\n      delete this._data;\n      delete this._previousData;\n      delete this._transaction;\n      delete this._affectedPathsIndex;\n      delete this._monkeys;\n\n      // Releasing cursors\n      for (k in this._cursors) this._cursors[k].release();\n      delete this._cursors;\n\n      // Killing event emitter\n      this.kill();\n    }\n\n    /**\n     * Overriding the `toJSON` method for convenient use with JSON.stringify.\n     *\n     * @return {mixed} - Data at cursor.\n     */\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return this.serialize();\n    }\n\n    /**\n     * Overriding the `toString` method for debugging purposes.\n     *\n     * @return {string} - The baobab's identity.\n     */\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this._identity;\n    }\n  }]);\n\n  return Baobab;\n})(_emmett2['default']);\n\nexports['default'] = Baobab;\nBaobab.monkey = function () {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  if (!args.length) throw new Error('Baobab.monkey: missing definition.');\n\n  if (args.length === 1 && typeof args[0] !== 'function') return new _monkey.MonkeyDefinition(args[0]);\n\n  return new _monkey.MonkeyDefinition(args);\n};\nBaobab.dynamicNode = Baobab.monkey;\n\n/**\n * Exposing some internals for convenience\n */\nBaobab.Cursor = _cursor2['default'];\nBaobab.MonkeyDefinition = _monkey.MonkeyDefinition;\nBaobab.Monkey = _monkey.Monkey;\nBaobab.type = _type2['default'];\nBaobab.helpers = helpers;\n\n/**\n * Version\n */\nBaobab.VERSION = '2.3.2';\nmodule.exports = exports['default'];\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/baobab/dist/baobab.js\n ** module id = 148\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/baobab/dist/baobab.js?");

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	eval("(function() {\n  'use strict';\n\n  /**\n   * Here is the list of every allowed parameter when using Emitter#on:\n   * @type {Object}\n   */\n  var __allowedOptions = {\n    once: 'boolean',\n    scope: 'object'\n  };\n\n  /**\n   * Incremental id used to order event handlers.\n   */\n  var __order = 0;\n\n  /**\n   * A simple helper to shallowly merge two objects. The second one will \"win\"\n   * over the first one.\n   *\n   * @param  {object}  o1 First target object.\n   * @param  {object}  o2 Second target object.\n   * @return {object}     Returns the merged object.\n   */\n  function shallowMerge(o1, o2) {\n    var o = {},\n        k;\n\n    for (k in o1) o[k] = o1[k];\n    for (k in o2) o[k] = o2[k];\n\n    return o;\n  }\n\n  /**\n   * Is the given variable a plain JavaScript object?\n   *\n   * @param  {mixed}  v   Target.\n   * @return {boolean}    The boolean result.\n   */\n  function isPlainObject(v) {\n    return v &&\n           typeof v === 'object' &&\n           !Array.isArray(v) &&\n           !(v instanceof Function) &&\n           !(v instanceof RegExp);\n  }\n\n  /**\n   * Iterate over an object that may have ES6 Symbols.\n   *\n   * @param  {object}   object  Object on which to iterate.\n   * @param  {function} fn      Iterator function.\n   * @param  {object}   [scope] Optional scope.\n   */\n  function forIn(object, fn, scope) {\n    var symbols,\n        k,\n        i,\n        l;\n\n    for (k in object)\n      fn.call(scope || null, k, object[k]);\n\n    if (Object.getOwnPropertySymbols) {\n      symbols = Object.getOwnPropertySymbols(object);\n\n      for (i = 0, l = symbols.length; i < l; i++)\n        fn.call(scope || null, symbols[i], object[symbols[i]]);\n    }\n  }\n\n  /**\n   * The emitter's constructor. It initializes the handlers-per-events store and\n   * the global handlers store.\n   *\n   * Emitters are useful for non-DOM events communication. Read its methods\n   * documentation for more information about how it works.\n   *\n   * @return {Emitter}         The fresh new instance.\n   */\n  var Emitter = function() {\n    this._enabled = true;\n\n    // Dirty trick that will set the necessary properties to the emitter\n    this.unbindAll();\n  };\n\n  /**\n   * This method unbinds every handlers attached to every or any events. So,\n   * these functions will no more be executed when the related events are\n   * emitted. If the functions were not bound to the events, nothing will\n   * happen, and no error will be thrown.\n   *\n   * Usage:\n   * ******\n   * > myEmitter.unbindAll();\n   *\n   * @return {Emitter}      Returns this.\n   */\n  Emitter.prototype.unbindAll = function() {\n\n    this._handlers = {};\n    this._handlersAll = [];\n    this._handlersComplex = [];\n\n    return this;\n  };\n\n\n  /**\n   * This method binds one or more functions to the emitter, handled to one or a\n   * suite of events. So, these functions will be executed anytime one related\n   * event is emitted.\n   *\n   * It is also possible to bind a function to any emitted event by not\n   * specifying any event to bind the function to.\n   *\n   * Recognized options:\n   * *******************\n   *  - {?boolean} once   If true, the handlers will be unbound after the first\n   *                      execution. Default value: false.\n   *  - {?object}  scope  If a scope is given, then the listeners will be called\n   *                      with this scope as \"this\".\n   *\n   * Variant 1:\n   * **********\n   * > myEmitter.on('myEvent', function(e) { console.log(e); });\n   * > // Or:\n   * > myEmitter.on('myEvent', function(e) { console.log(e); }, { once: true });\n   *\n   * @param  {string}   event   The event to listen to.\n   * @param  {function} handler The function to bind.\n   * @param  {?object}  options Eventually some options.\n   * @return {Emitter}          Returns this.\n   *\n   * Variant 2:\n   * **********\n   * > myEmitter.on(\n   * >   ['myEvent1', 'myEvent2'],\n   * >   function(e) { console.log(e); }\n   * >);\n   * > // Or:\n   * > myEmitter.on(\n   * >   ['myEvent1', 'myEvent2'],\n   * >   function(e) { console.log(e); }\n   * >   { once: true }}\n   * >);\n   *\n   * @param  {array}    events  The events to listen to.\n   * @param  {function} handler The function to bind.\n   * @param  {?object}  options Eventually some options.\n   * @return {Emitter}          Returns this.\n   *\n   * Variant 3:\n   * **********\n   * > myEmitter.on({\n   * >   myEvent1: function(e) { console.log(e); },\n   * >   myEvent2: function(e) { console.log(e); }\n   * > });\n   * > // Or:\n   * > myEmitter.on({\n   * >   myEvent1: function(e) { console.log(e); },\n   * >   myEvent2: function(e) { console.log(e); }\n   * > }, { once: true });\n   *\n   * @param  {object}  bindings An object containing pairs event / function.\n   * @param  {?object}  options Eventually some options.\n   * @return {Emitter}          Returns this.\n   *\n   * Variant 4:\n   * **********\n   * > myEmitter.on(function(e) { console.log(e); });\n   * > // Or:\n   * > myEmitter.on(function(e) { console.log(e); }, { once: true});\n   *\n   * @param  {function} handler The function to bind to every events.\n   * @param  {?object}  options Eventually some options.\n   * @return {Emitter}          Returns this.\n   */\n  Emitter.prototype.on = function(a, b, c) {\n    var i,\n        l,\n        k,\n        event,\n        eArray,\n        handlersList,\n        bindingObject;\n\n    // Variant 3\n    if (isPlainObject(a)) {\n      forIn(a, function(name, fn) {\n        this.on(name, fn, b);\n      }, this);\n\n      return this;\n    }\n\n    // Variant 1, 2 and 4\n    if (typeof a === 'function') {\n      c = b;\n      b = a;\n      a = null;\n    }\n\n    eArray = [].concat(a);\n\n    for (i = 0, l = eArray.length; i < l; i++) {\n      event = eArray[i];\n\n      bindingObject = {\n        order: __order++,\n        fn: b\n      };\n\n      // Defining the list in which the handler should be inserted\n      if (typeof event === 'string' || typeof event === 'symbol') {\n        if (!this._handlers[event])\n          this._handlers[event] = [];\n        handlersList = this._handlers[event];\n        bindingObject.type = event;\n      }\n      else if (event instanceof RegExp) {\n        handlersList = this._handlersComplex;\n        bindingObject.pattern = event;\n      }\n      else if (event === null) {\n        handlersList = this._handlersAll;\n      }\n      else {\n        throw Error('Emitter.on: invalid event.');\n      }\n\n      // Appending needed properties\n      for (k in c || {})\n        if (__allowedOptions[k])\n          bindingObject[k] = c[k];\n\n      handlersList.push(bindingObject);\n    }\n\n    return this;\n  };\n\n\n  /**\n   * This method works exactly as the previous #on, but will add an options\n   * object if none is given, and set the option \"once\" to true.\n   *\n   * The polymorphism works exactly as with the #on method.\n   */\n  Emitter.prototype.once = function() {\n    var args = Array.prototype.slice.call(arguments),\n        li = args.length - 1;\n\n    if (isPlainObject(args[li]) && args.length > 1)\n      args[li] = shallowMerge(args[li], {once: true});\n    else\n      args.push({once: true});\n\n    return this.on.apply(this, args);\n  };\n\n\n  /**\n   * This method unbinds one or more functions from events of the emitter. So,\n   * these functions will no more be executed when the related events are\n   * emitted. If the functions were not bound to the events, nothing will\n   * happen, and no error will be thrown.\n   *\n   * Variant 1:\n   * **********\n   * > myEmitter.off('myEvent', myHandler);\n   *\n   * @param  {string}   event   The event to unbind the handler from.\n   * @param  {function} handler The function to unbind.\n   * @return {Emitter}          Returns this.\n   *\n   * Variant 2:\n   * **********\n   * > myEmitter.off(['myEvent1', 'myEvent2'], myHandler);\n   *\n   * @param  {array}    events  The events to unbind the handler from.\n   * @param  {function} handler The function to unbind.\n   * @return {Emitter}          Returns this.\n   *\n   * Variant 3:\n   * **********\n   * > myEmitter.off({\n   * >   myEvent1: myHandler1,\n   * >   myEvent2: myHandler2\n   * > });\n   *\n   * @param  {object} bindings An object containing pairs event / function.\n   * @return {Emitter}         Returns this.\n   *\n   * Variant 4:\n   * **********\n   * > myEmitter.off(myHandler);\n   *\n   * @param  {function} handler The function to unbind from every events.\n   * @return {Emitter}          Returns this.\n   *\n   * Variant 5:\n   * **********\n   * > myEmitter.off(event);\n   *\n   * @param  {string} event     The event we should unbind.\n   * @return {Emitter}          Returns this.\n   */\n  function filter(target, fn) {\n    target = target || [];\n\n    var a = [],\n        l,\n        i;\n\n    for (i = 0, l = target.length; i < l; i++)\n      if (target[i].fn !== fn)\n        a.push(target[i]);\n\n    return a;\n  }\n\n  Emitter.prototype.off = function(events, fn) {\n    var i,\n        n,\n        k,\n        event;\n\n    // Variant 4:\n    if (arguments.length === 1 && typeof events === 'function') {\n      fn = arguments[0];\n\n      // Handlers bound to events:\n      for (k in this._handlers) {\n        this._handlers[k] = filter(this._handlers[k], fn);\n\n        if (this._handlers[k].length === 0)\n          delete this._handlers[k];\n      }\n\n      // Generic Handlers\n      this._handlersAll = filter(this._handlersAll, fn);\n\n      // Complex handlers\n      this._handlersComplex = filter(this._handlersComplex, fn);\n    }\n\n    // Variant 5\n    else if (arguments.length === 1 &&\n             (typeof events === 'string' || typeof events === 'symbol')) {\n      delete this._handlers[events];\n    }\n\n    // Variant 1 and 2:\n    else if (arguments.length === 2) {\n      var eArray = [].concat(events);\n\n      for (i = 0, n = eArray.length; i < n; i++) {\n        event = eArray[i];\n\n        this._handlers[event] = filter(this._handlers[event], fn);\n\n        if ((this._handlers[event] || []).length === 0)\n          delete this._handlers[event];\n      }\n    }\n\n    // Variant 3\n    else if (isPlainObject(events)) {\n      forIn(events, this.off, this);\n    }\n\n    return this;\n  };\n\n  /**\n   * This method retrieve the listeners attached to a particular event.\n   *\n   * @param  {?string}    Name of the event.\n   * @return {array}      Array of handler functions.\n   */\n  Emitter.prototype.listeners = function(event) {\n    var handlers = this._handlersAll || [],\n        complex = false,\n        h,\n        i,\n        l;\n\n    if (!event)\n      throw Error('Emitter.listeners: no event provided.');\n\n    handlers = handlers.concat(this._handlers[event] || []);\n\n    for (i = 0, l = this._handlersComplex.length; i < l; i++) {\n      h = this._handlersComplex[i];\n\n      if (~event.search(h.pattern)) {\n        complex = true;\n        handlers.push(h);\n      }\n    }\n\n    // If we have any complex handlers, we need to sort\n    if (this._handlersAll.length || complex)\n      return handlers.sort(function(a, b) {\n        return a.order - b.order;\n      });\n    else\n      return handlers.slice(0);\n  };\n\n  /**\n   * This method emits the specified event(s), and executes every handlers bound\n   * to the event(s).\n   *\n   * Use cases:\n   * **********\n   * > myEmitter.emit('myEvent');\n   * > myEmitter.emit('myEvent', myData);\n   * > myEmitter.emit(['myEvent1', 'myEvent2']);\n   * > myEmitter.emit(['myEvent1', 'myEvent2'], myData);\n   * > myEmitter.emit({myEvent1: myData1, myEvent2: myData2});\n   *\n   * @param  {string|array} events The event(s) to emit.\n   * @param  {object?}      data   The data.\n   * @return {Emitter}             Returns this.\n   */\n  Emitter.prototype.emit = function(events, data) {\n\n    // Short exit if the emitter is disabled\n    if (!this._enabled)\n      return this;\n\n    // Object variant\n    if (isPlainObject(events)) {\n      forIn(events, this.emit, this);\n      return this;\n    }\n\n    var eArray = [].concat(events),\n        onces = [],\n        event,\n        parent,\n        handlers,\n        handler,\n        i,\n        j,\n        l,\n        m;\n\n    for (i = 0, l = eArray.length; i < l; i++) {\n      handlers = this.listeners(eArray[i]);\n\n      for (j = 0, m = handlers.length; j < m; j++) {\n        handler = handlers[j];\n        event = {\n          type: eArray[i],\n          target: this\n        };\n\n        if (arguments.length > 1)\n          event.data = data;\n\n        handler.fn.call('scope' in handler ? handler.scope : this, event);\n\n        if (handler.once)\n          onces.push(handler);\n      }\n\n      // Cleaning onces\n      for (j = onces.length - 1; j >= 0; j--) {\n        parent = onces[j].type ?\n          this._handlers[onces[j].type] :\n          onces[j].pattern ?\n            this._handlersComplex :\n            this._handlersAll;\n\n        parent.splice(parent.indexOf(onces[j]), 1);\n      }\n    }\n\n    return this;\n  };\n\n\n  /**\n   * This method will unbind all listeners and make it impossible to ever\n   * rebind any listener to any event.\n   */\n  Emitter.prototype.kill = function() {\n\n    this.unbindAll();\n    this._handlers = null;\n    this._handlersAll = null;\n    this._handlersComplex = null;\n    this._enabled = false;\n\n    // Nooping methods\n    this.unbindAll =\n    this.on =\n    this.once =\n    this.off =\n    this.emit =\n    this.listeners = Function.prototype;\n  };\n\n\n  /**\n   * This method disabled the emitter, which means its emit method will do\n   * nothing.\n   *\n   * @return {Emitter} Returns this.\n   */\n  Emitter.prototype.disable = function() {\n    this._enabled = false;\n\n    return this;\n  };\n\n\n  /**\n   * This method enables the emitter.\n   *\n   * @return {Emitter} Returns this.\n   */\n  Emitter.prototype.enable = function() {\n    this._enabled = true;\n\n    return this;\n  };\n\n\n  /**\n   * Version:\n   */\n  Emitter.version = '3.1.1';\n\n\n  // Export:\n  if (true) {\n    if (typeof module !== 'undefined' && module.exports)\n      exports = module.exports = Emitter;\n    exports.Emitter = Emitter;\n  } else if (typeof define === 'function' && define.amd)\n    define('emmett', [], function() {\n      return Emitter;\n    });\n  else\n    this.Emitter = Emitter;\n}).call(this);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/emmett/emmett.js\n ** module id = 149\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/emmett/emmett.js?");

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Baobab Cursors\n * ===============\n *\n * Cursors created by selecting some data within a Baobab tree.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _emmett = __webpack_require__(149);\n\nvar _emmett2 = _interopRequireDefault(_emmett);\n\nvar _monkey = __webpack_require__(151);\n\nvar _type = __webpack_require__(152);\n\nvar _type2 = _interopRequireDefault(_type);\n\nvar _helpers = __webpack_require__(154);\n\n/**\n * Traversal helper function for dynamic cursors. Will throw a legible error\n * if traversal is not possible.\n *\n * @param {string} method     - The method name, to create a correct error msg.\n * @param {array}  solvedPath - The cursor's solved path.\n */\nfunction checkPossibilityOfDynamicTraversal(method, solvedPath) {\n  if (!solvedPath) throw (0, _helpers.makeError)('Baobab.Cursor.' + method + ': ' + ('cannot use ' + method + ' on an unresolved dynamic path.'), { path: solvedPath });\n}\n\n/**\n * Cursor class\n *\n * @constructor\n * @param {Baobab} tree   - The cursor's root.\n * @param {array}  path   - The cursor's path in the tree.\n * @param {string} hash   - The path's hash computed ahead by the tree.\n */\n\nvar Cursor = (function (_Emitter) {\n  _inherits(Cursor, _Emitter);\n\n  function Cursor(tree, path, hash) {\n    var _this = this;\n\n    _classCallCheck(this, Cursor);\n\n    _get(Object.getPrototypeOf(Cursor.prototype), 'constructor', this).call(this);\n\n    // If no path were to be provided, we fallback to an empty path (root)\n    path = path || [];\n\n    // Privates\n    this._identity = '[object Cursor]';\n    this._archive = null;\n\n    // Properties\n    this.tree = tree;\n    this.path = path;\n    this.hash = hash;\n\n    // State\n    this.state = {\n      killed: false,\n      recording: false,\n      undoing: false\n    };\n\n    // Checking whether the given path is dynamic or not\n    this._dynamicPath = _type2['default'].dynamicPath(this.path);\n\n    // Checking whether the given path will meet a monkey\n    this._monkeyPath = _type2['default'].monkeyPath(this.tree._monkeys, this.path);\n\n    if (!this._dynamicPath) this.solvedPath = this.path;else this.solvedPath = (0, _helpers.getIn)(this.tree._data, this.path).solvedPath;\n\n    /**\n     * Listener bound to the tree's writes so that cursors with dynamic paths\n     * may update their solved path correctly.\n     *\n     * @param {object} event - The event fired by the tree.\n     */\n    this._writeHandler = function (_ref) {\n      var data = _ref.data;\n\n      if (_this.state.killed || !(0, _helpers.solveUpdate)([data.path], _this._getComparedPaths())) return;\n\n      _this.solvedPath = (0, _helpers.getIn)(_this.tree._data, _this.path).solvedPath;\n    };\n\n    /**\n     * Function in charge of actually trigger the cursor's updates and\n     * deal with the archived records.\n     *\n     * @note: probably should wrap the current solvedPath in closure to avoid\n     * for tricky cases where it would fail.\n     *\n     * @param {mixed} previousData - the tree's previous data.\n     */\n    var fireUpdate = function fireUpdate(previousData) {\n      var self = _this;\n\n      var eventData = Object.defineProperties({}, {\n        previousData: {\n          get: function get() {\n            return (0, _helpers.getIn)(previousData, self.solvedPath).data;\n          },\n          configurable: true,\n          enumerable: true\n        },\n        currentData: {\n          get: function get() {\n            return self.get();\n          },\n          configurable: true,\n          enumerable: true\n        }\n      });\n\n      if (_this.state.recording && !_this.state.undoing) _this.archive.add(eventData.previousData);\n\n      _this.state.undoing = false;\n\n      return _this.emit('update', eventData);\n    };\n\n    /**\n     * Listener bound to the tree's updates and determining whether the\n     * cursor is affected and should react accordingly.\n     *\n     * Note that this listener is lazily bound to the tree to be sure\n     * one wouldn't leak listeners when only creating cursors for convenience\n     * and not to listen to updates specifically.\n     *\n     * @param {object} event - The event fired by the tree.\n     */\n    this._updateHandler = function (event) {\n      if (_this.state.killed) return;\n\n      var _event$data = event.data;\n      var paths = _event$data.paths;\n      var previousData = _event$data.previousData;\n      var update = fireUpdate.bind(_this, previousData);\n      var comparedPaths = _this._getComparedPaths();\n\n      if ((0, _helpers.solveUpdate)(paths, comparedPaths)) return update();\n    };\n\n    // Lazy binding\n    var bound = false;\n    this._lazyBind = function () {\n      if (bound) return;\n\n      bound = true;\n\n      if (_this._dynamicPath) _this.tree.on('write', _this._writeHandler);\n\n      return _this.tree.on('update', _this._updateHandler);\n    };\n\n    // If the path is dynamic, we actually need to listen to the tree\n    if (this._dynamicPath) {\n      this._lazyBind();\n    } else {\n\n      // Overriding the emitter `on` and `once` methods\n      this.on = (0, _helpers.before)(this._lazyBind, this.on.bind(this));\n      this.once = (0, _helpers.before)(this._lazyBind, this.once.bind(this));\n    }\n  }\n\n  /**\n   * Method used to allow iterating over cursors containing list-type data.\n   *\n   * e.g. for(let i of cursor) { ... }\n   *\n   * @returns {object} -  Each item sequentially.\n   */\n\n  /**\n   * Internal helpers\n   * -----------------\n   */\n\n  /**\n   * Method returning the paths of the tree watched over by the cursor and that\n   * should be taken into account when solving a potential update.\n   *\n   * @return {array} - Array of paths to compare with a given update.\n   */\n\n  _createClass(Cursor, [{\n    key: '_getComparedPaths',\n    value: function _getComparedPaths() {\n\n      // Checking whether we should keep track of some dependencies\n      var additionalPaths = this._monkeyPath ? (0, _helpers.getIn)(this.tree._monkeys, this._monkeyPath).data.relatedPaths() : [];\n\n      return [this.solvedPath].concat(additionalPaths);\n    }\n\n    /**\n     * Predicates\n     * -----------\n     */\n\n    /**\n     * Method returning whether the cursor is at root level.\n     *\n     * @return {boolean} - Is the cursor the root?\n     */\n  }, {\n    key: 'isRoot',\n    value: function isRoot() {\n      return !this.path.length;\n    }\n\n    /**\n     * Method returning whether the cursor is at leaf level.\n     *\n     * @return {boolean} - Is the cursor a leaf?\n     */\n  }, {\n    key: 'isLeaf',\n    value: function isLeaf() {\n      return _type2['default'].primitive(this._get().data);\n    }\n\n    /**\n     * Method returning whether the cursor is at branch level.\n     *\n     * @return {boolean} - Is the cursor a branch?\n     */\n  }, {\n    key: 'isBranch',\n    value: function isBranch() {\n      return !this.isRoot() && !this.isLeaf();\n    }\n\n    /**\n     * Traversal Methods\n     * ------------------\n     */\n\n    /**\n     * Method returning the root cursor.\n     *\n     * @return {Baobab} - The root cursor.\n     */\n  }, {\n    key: 'root',\n    value: function root() {\n      return this.tree.select();\n    }\n\n    /**\n     * Method selecting a subpath as a new cursor.\n     *\n     * Arity (1):\n     * @param  {path} path    - The path to select.\n     *\n     * Arity (*):\n     * @param  {...step} path - The path to select.\n     *\n     * @return {Cursor}       - The created cursor.\n     */\n  }, {\n    key: 'select',\n    value: function select(path) {\n      if (arguments.length > 1) path = (0, _helpers.arrayFrom)(arguments);\n\n      return this.tree.select(this.path.concat(path));\n    }\n\n    /**\n     * Method returning the parent node of the cursor or else `null` if the\n     * cursor is already at root level.\n     *\n     * @return {Baobab} - The parent cursor.\n     */\n  }, {\n    key: 'up',\n    value: function up() {\n      if (!this.isRoot()) return this.tree.select(this.path.slice(0, -1));\n\n      return null;\n    }\n\n    /**\n     * Method returning the child node of the cursor.\n     *\n     * @return {Baobab} - The child cursor.\n     */\n  }, {\n    key: 'down',\n    value: function down() {\n      checkPossibilityOfDynamicTraversal('down', this.solvedPath);\n\n      if (!(this._get().data instanceof Array)) throw Error('Baobab.Cursor.down: cannot go down on a non-list type.');\n\n      return this.tree.select(this.solvedPath.concat(0));\n    }\n\n    /**\n     * Method returning the left sibling node of the cursor if this one is\n     * pointing at a list. Returns `null` if this cursor is already leftmost.\n     *\n     * @return {Baobab} - The left sibling cursor.\n     */\n  }, {\n    key: 'left',\n    value: function left() {\n      checkPossibilityOfDynamicTraversal('left', this.solvedPath);\n\n      var last = +this.solvedPath[this.solvedPath.length - 1];\n\n      if (isNaN(last)) throw Error('Baobab.Cursor.left: cannot go left on a non-list type.');\n\n      return last ? this.tree.select(this.solvedPath.slice(0, -1).concat(last - 1)) : null;\n    }\n\n    /**\n     * Method returning the right sibling node of the cursor if this one is\n     * pointing at a list. Returns `null` if this cursor is already rightmost.\n     *\n     * @return {Baobab} - The right sibling cursor.\n     */\n  }, {\n    key: 'right',\n    value: function right() {\n      checkPossibilityOfDynamicTraversal('right', this.solvedPath);\n\n      var last = +this.solvedPath[this.solvedPath.length - 1];\n\n      if (isNaN(last)) throw Error('Baobab.Cursor.right: cannot go right on a non-list type.');\n\n      if (last + 1 === this.up()._get().data.length) return null;\n\n      return this.tree.select(this.solvedPath.slice(0, -1).concat(last + 1));\n    }\n\n    /**\n     * Method returning the leftmost sibling node of the cursor if this one is\n     * pointing at a list.\n     *\n     * @return {Baobab} - The leftmost sibling cursor.\n     */\n  }, {\n    key: 'leftmost',\n    value: function leftmost() {\n      checkPossibilityOfDynamicTraversal('leftmost', this.solvedPath);\n\n      var last = +this.solvedPath[this.solvedPath.length - 1];\n\n      if (isNaN(last)) throw Error('Baobab.Cursor.leftmost: cannot go left on a non-list type.');\n\n      return this.tree.select(this.solvedPath.slice(0, -1).concat(0));\n    }\n\n    /**\n     * Method returning the rightmost sibling node of the cursor if this one is\n     * pointing at a list.\n     *\n     * @return {Baobab} - The rightmost sibling cursor.\n     */\n  }, {\n    key: 'rightmost',\n    value: function rightmost() {\n      checkPossibilityOfDynamicTraversal('rightmost', this.solvedPath);\n\n      var last = +this.solvedPath[this.solvedPath.length - 1];\n\n      if (isNaN(last)) throw Error('Baobab.Cursor.rightmost: cannot go right on a non-list type.');\n\n      var list = this.up()._get().data;\n\n      return this.tree.select(this.solvedPath.slice(0, -1).concat(list.length - 1));\n    }\n\n    /**\n     * Method mapping the children nodes of the cursor.\n     *\n     * @param  {function} fn      - The function to map.\n     * @param  {object}   [scope] - An optional scope.\n     * @return {array}            - The resultant array.\n     */\n  }, {\n    key: 'map',\n    value: function map(fn, scope) {\n      checkPossibilityOfDynamicTraversal('map', this.solvedPath);\n\n      var array = this._get().data,\n          l = arguments.length;\n\n      if (!_type2['default'].array(array)) throw Error('baobab.Cursor.map: cannot map a non-list type.');\n\n      return array.map(function (item, i) {\n        return fn.call(l > 1 ? scope : this, this.select(i), i, array);\n      }, this);\n    }\n\n    /**\n     * Getter Methods\n     * ---------------\n     */\n\n    /**\n     * Internal get method. Basically contains the main body of the `get` method\n     * without the event emitting. This is sometimes needed not to fire useless\n     * events.\n     *\n     * @param  {path}   [path=[]]       - Path to get in the tree.\n     * @return {object} info            - The resultant information.\n     * @return {mixed}  info.data       - Data at path.\n     * @return {array}  info.solvedPath - The path solved when getting.\n     */\n  }, {\n    key: '_get',\n    value: function _get() {\n      var path = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\n      if (!_type2['default'].path(path)) throw (0, _helpers.makeError)('Baobab.Cursor.getters: invalid path.', { path: path });\n\n      if (!this.solvedPath) return { data: undefined, solvedPath: null, exists: false };\n\n      return (0, _helpers.getIn)(this.tree._data, this.solvedPath.concat(path));\n    }\n\n    /**\n     * Method used to check whether a certain path exists in the tree starting\n     * from the current cursor.\n     *\n     * Arity (1):\n     * @param  {path}   path           - Path to check in the tree.\n     *\n     * Arity (2):\n     * @param {..step}  path           - Path to check in the tree.\n     *\n     * @return {boolean}               - Does the given path exists?\n     */\n  }, {\n    key: 'exists',\n    value: function exists(path) {\n      path = (0, _helpers.coercePath)(path);\n\n      if (arguments.length > 1) path = (0, _helpers.arrayFrom)(arguments);\n\n      return this._get(path).exists;\n    }\n\n    /**\n     * Method used to get data from the tree. Will fire a `get` event from the\n     * tree so that the user may sometimes react upon it to fetch data, for\n     * instance.\n     *\n     * Arity (1):\n     * @param  {path}   path           - Path to get in the tree.\n     *\n     * Arity (2):\n     * @param  {..step} path           - Path to get in the tree.\n     *\n     * @return {mixed}                 - Data at path.\n     */\n  }, {\n    key: 'get',\n    value: function get(path) {\n      path = (0, _helpers.coercePath)(path);\n\n      if (arguments.length > 1) path = (0, _helpers.arrayFrom)(arguments);\n\n      var _get2 = this._get(path);\n\n      var data = _get2.data;\n      var solvedPath = _get2.solvedPath;\n\n      // Emitting the event\n      this.tree.emit('get', { data: data, solvedPath: solvedPath, path: this.path.concat(path) });\n\n      return data;\n    }\n\n    /**\n     * Method used to shallow clone data from the tree.\n     *\n     * Arity (1):\n     * @param  {path}   path           - Path to get in the tree.\n     *\n     * Arity (2):\n     * @param  {..step} path           - Path to get in the tree.\n     *\n     * @return {mixed}                 - Cloned data at path.\n     */\n  }, {\n    key: 'clone',\n    value: function clone() {\n      var data = this.get.apply(this, arguments);\n\n      return (0, _helpers.shallowClone)(data);\n    }\n\n    /**\n     * Method used to deep clone data from the tree.\n     *\n     * Arity (1):\n     * @param  {path}   path           - Path to get in the tree.\n     *\n     * Arity (2):\n     * @param  {..step} path           - Path to get in the tree.\n     *\n     * @return {mixed}                 - Cloned data at path.\n     */\n  }, {\n    key: 'deepClone',\n    value: function deepClone() {\n      var data = this.get.apply(this, arguments);\n\n      return (0, _helpers.deepClone)(data);\n    }\n\n    /**\n     * Method used to return raw data from the tree, by carefully avoiding\n     * computed one.\n     *\n     * @todo: should be more performant as the cloning should happen as well as\n     * when dropping computed data.\n     *\n     * Arity (1):\n     * @param  {path}   path           - Path to serialize in the tree.\n     *\n     * Arity (2):\n     * @param  {..step} path           - Path to serialize in the tree.\n     *\n     * @return {mixed}                 - The retrieved raw data.\n     */\n  }, {\n    key: 'serialize',\n    value: function serialize(path) {\n      path = (0, _helpers.coercePath)(path);\n\n      if (arguments.length > 1) path = (0, _helpers.arrayFrom)(arguments);\n\n      if (!_type2['default'].path(path)) throw (0, _helpers.makeError)('Baobab.Cursor.getters: invalid path.', { path: path });\n\n      if (!this.solvedPath) return undefined;\n\n      var fullPath = this.solvedPath.concat(path);\n\n      var data = (0, _helpers.deepClone)((0, _helpers.getIn)(this.tree._data, fullPath).data),\n          monkeys = (0, _helpers.getIn)(this.tree._monkeys, fullPath).data;\n\n      var dropComputedData = function dropComputedData(d, m) {\n        if (!_type2['default'].object(m) || !_type2['default'].object(d)) return;\n\n        for (var k in m) {\n          if (m[k] instanceof _monkey.Monkey) delete d[k];else dropComputedData(d[k], m[k]);\n        }\n      };\n\n      dropComputedData(data, monkeys);\n      return data;\n    }\n\n    /**\n     * Method used to project some of the data at cursor onto a map or a list.\n     *\n     * @param  {object|array} projection - The projection's formal definition.\n     * @return {object|array}            - The resultant map/list.\n     */\n  }, {\n    key: 'project',\n    value: function project(projection) {\n      if (_type2['default'].object(projection)) {\n        var data = {};\n\n        for (var k in projection) {\n          data[k] = this.get(projection[k]);\n        }return data;\n      } else if (_type2['default'].array(projection)) {\n        var data = [];\n\n        for (var i = 0, l = projection.length; i < l; i++) {\n          data.push(this.get(projection[i]));\n        }return data;\n      }\n\n      throw (0, _helpers.makeError)('Baobab.Cursor.project: wrong projection.', { projection: projection });\n    }\n\n    /**\n     * History Methods\n     * ----------------\n     */\n\n    /**\n     * Methods starting to record the cursor's successive states.\n     *\n     * @param  {integer} [maxRecords] - Maximum records to keep in memory. Note\n     *                                  that if no number is provided, the cursor\n     *                                  will keep everything.\n     * @return {Cursor}               - The cursor instance for chaining purposes.\n     */\n  }, {\n    key: 'startRecording',\n    value: function startRecording(maxRecords) {\n      maxRecords = maxRecords || Infinity;\n\n      if (maxRecords < 1) throw (0, _helpers.makeError)('Baobab.Cursor.startRecording: invalid max records.', {\n        value: maxRecords\n      });\n\n      this.state.recording = true;\n\n      if (this.archive) return this;\n\n      // Lazy binding\n      this._lazyBind();\n\n      this.archive = new _helpers.Archive(maxRecords);\n      return this;\n    }\n\n    /**\n     * Methods stopping to record the cursor's successive states.\n     *\n     * @return {Cursor} - The cursor instance for chaining purposes.\n     */\n  }, {\n    key: 'stopRecording',\n    value: function stopRecording() {\n      this.state.recording = false;\n      return this;\n    }\n\n    /**\n     * Methods undoing n steps of the cursor's recorded states.\n     *\n     * @param  {integer} [steps=1] - The number of steps to rollback.\n     * @return {Cursor}            - The cursor instance for chaining purposes.\n     */\n  }, {\n    key: 'undo',\n    value: function undo() {\n      var steps = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];\n\n      if (!this.state.recording) throw new Error('Baobab.Cursor.undo: cursor is not recording.');\n\n      var record = this.archive.back(steps);\n\n      if (!record) throw Error('Baobab.Cursor.undo: cannot find a relevant record.');\n\n      this.state.undoing = true;\n      this.set(record);\n\n      return this;\n    }\n\n    /**\n     * Methods returning whether the cursor has a recorded history.\n     *\n     * @return {boolean} - `true` if the cursor has a recorded history?\n     */\n  }, {\n    key: 'hasHistory',\n    value: function hasHistory() {\n      return !!(this.archive && this.archive.get().length);\n    }\n\n    /**\n     * Methods returning the cursor's history.\n     *\n     * @return {array} - The cursor's history.\n     */\n  }, {\n    key: 'getHistory',\n    value: function getHistory() {\n      return this.archive ? this.archive.get() : [];\n    }\n\n    /**\n     * Methods clearing the cursor's history.\n     *\n     * @return {Cursor} - The cursor instance for chaining purposes.\n     */\n  }, {\n    key: 'clearHistory',\n    value: function clearHistory() {\n      if (this.archive) this.archive.clear();\n      return this;\n    }\n\n    /**\n     * Releasing\n     * ----------\n     */\n\n    /**\n     * Methods releasing the cursor from memory.\n     */\n  }, {\n    key: 'release',\n    value: function release() {\n\n      // Removing listeners on parent\n      if (this._dynamicPath) this.tree.off('write', this._writeHandler);\n\n      this.tree.off('update', this._updateHandler);\n\n      // Unsubscribe from the parent\n      if (this.hash) delete this.tree._cursors[this.hash];\n\n      // Dereferencing\n      delete this.tree;\n      delete this.path;\n      delete this.solvedPath;\n      delete this.archive;\n\n      // Killing emitter\n      this.kill();\n      this.state.killed = true;\n    }\n\n    /**\n     * Output\n     * -------\n     */\n\n    /**\n     * Overriding the `toJSON` method for convenient use with JSON.stringify.\n     *\n     * @return {mixed} - Data at cursor.\n     */\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return this.serialize();\n    }\n\n    /**\n     * Overriding the `toString` method for debugging purposes.\n     *\n     * @return {string} - The cursor's identity.\n     */\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this._identity;\n    }\n  }]);\n\n  return Cursor;\n})(_emmett2['default']);\n\nexports['default'] = Cursor;\nif (typeof Symbol === 'function' && typeof Symbol.iterator !== 'undefined') {\n  Cursor.prototype[Symbol.iterator] = function () {\n    var array = this._get().data;\n\n    if (!_type2['default'].array(array)) throw Error('baobab.Cursor.@@iterate: cannot iterate a non-list type.');\n\n    var i = 0;\n\n    var cursor = this,\n        length = array.length;\n\n    return {\n      next: function next() {\n        if (i < length) {\n          return {\n            value: cursor.select(i++)\n          };\n        }\n\n        return {\n          done: true\n        };\n      }\n    };\n  };\n}\n\n/**\n * Setter Methods\n * ---------------\n *\n * Those methods are dynamically assigned to the class for DRY reasons.\n */\n\n// Not using a Set so that ES5 consumers don't pay a bundle size price\nvar INTRANSITIVE_SETTERS = {\n  unset: true,\n  pop: true,\n  shift: true\n};\n\n/**\n * Function creating a setter method for the Cursor class.\n *\n * @param {string}   name          - the method's name.\n * @param {function} [typeChecker] - a function checking that the given value is\n *                                   valid for the given operation.\n */\nfunction makeSetter(name, typeChecker) {\n\n  /**\n   * Binding a setter method to the Cursor class and having the following\n   * definition.\n   *\n   * Note: this is not really possible to make those setters variadic because\n   * it would create an impossible polymorphism with path.\n   *\n   * @todo: perform value validation elsewhere so that tree.update can\n   * beneficiate from it.\n   *\n   * Arity (1):\n   * @param  {mixed} value - New value to set at cursor's path.\n   *\n   * Arity (2):\n   * @param  {path}  path  - Subpath to update starting from cursor's.\n   * @param  {mixed} value - New value to set.\n   *\n   * @return {mixed}       - Data at path.\n   */\n  Cursor.prototype[name] = function (path, value) {\n\n    // We should warn the user if he applies to many arguments to the function\n    if (arguments.length > 2) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': too many arguments.');\n\n    // Handling arities\n    if (arguments.length === 1 && !INTRANSITIVE_SETTERS[name]) {\n      value = path;\n      path = [];\n    }\n\n    // Coerce path\n    path = (0, _helpers.coercePath)(path);\n\n    // Checking the path's validity\n    if (!_type2['default'].path(path)) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid path.', { path: path });\n\n    // Checking the value's validity\n    if (typeChecker && !typeChecker(value)) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid value.', { path: path, value: value });\n\n    // Checking the solvability of the cursor's dynamic path\n    if (!this.solvedPath) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': the dynamic path of the cursor cannot be solved.', { path: this.path });\n\n    var fullPath = this.solvedPath.concat(path);\n\n    // Filing the update to the tree\n    return this.tree.update(fullPath, {\n      type: name,\n      value: value\n    });\n  };\n}\n\n/**\n * Making the necessary setters.\n */\nmakeSetter('set');\nmakeSetter('unset');\nmakeSetter('apply', _type2['default']['function']);\nmakeSetter('push');\nmakeSetter('concat', _type2['default'].array);\nmakeSetter('unshift');\nmakeSetter('pop');\nmakeSetter('shift');\nmakeSetter('splice', _type2['default'].splicer);\nmakeSetter('merge', _type2['default'].object);\nmakeSetter('deepMerge', _type2['default'].object);\nmodule.exports = exports['default'];\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/baobab/dist/cursor.js\n ** module id = 150\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/baobab/dist/cursor.js?");

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Baobab Monkeys\n * ===============\n *\n * Exposing both handy monkey definitions and the underlying working class.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _type = __webpack_require__(152);\n\nvar _type2 = _interopRequireDefault(_type);\n\nvar _update2 = __webpack_require__(153);\n\nvar _update3 = _interopRequireDefault(_update2);\n\nvar _helpers = __webpack_require__(154);\n\n/**\n * Monkey Definition class\n * Note: The only reason why this is a class is to be able to spot it within\n * otherwise ordinary data.\n *\n * @constructor\n * @param {array|object} definition - The formal definition of the monkey.\n */\n\nvar MonkeyDefinition = function MonkeyDefinition(definition) {\n  var _this = this;\n\n  _classCallCheck(this, MonkeyDefinition);\n\n  var monkeyType = _type2['default'].monkeyDefinition(definition);\n\n  if (!monkeyType) throw (0, _helpers.makeError)('Baobab.monkey: invalid definition.', { definition: definition });\n\n  this.type = monkeyType;\n\n  if (this.type === 'object') {\n    this.getter = definition.get;\n    this.projection = definition.cursors || {};\n    this.paths = Object.keys(this.projection).map(function (k) {\n      return _this.projection[k];\n    });\n    this.options = definition.options || {};\n  } else {\n    var offset = 1,\n        options = {};\n\n    if (_type2['default'].object(definition[definition.length - 1])) {\n      offset++;\n      options = definition[definition.length - 1];\n    }\n\n    this.getter = definition[definition.length - offset];\n    this.projection = definition.slice(0, -offset);\n    this.paths = this.projection;\n    this.options = options;\n  }\n\n  // Coercing paths for convenience\n  this.paths = this.paths.map(function (p) {\n    return [].concat(p);\n  });\n\n  // Does the definition contain dynamic paths\n  this.hasDynamicPaths = this.paths.some(_type2['default'].dynamicPath);\n}\n\n/**\n * Monkey core class\n *\n * @constructor\n * @param {Baobab}           tree       - The bound tree.\n * @param {MonkeyDefinition} definition - A definition instance.\n */\n;\n\nexports.MonkeyDefinition = MonkeyDefinition;\n\nvar Monkey = (function () {\n  function Monkey(tree, pathInTree, definition) {\n    var _this2 = this;\n\n    _classCallCheck(this, Monkey);\n\n    // Properties\n    this.tree = tree;\n    this.path = pathInTree;\n    this.definition = definition;\n\n    // Adapting the definition's paths & projection to this monkey's case\n    var projection = definition.projection,\n        relative = _helpers.solveRelativePath.bind(null, pathInTree.slice(0, -1));\n\n    if (definition.type === 'object') {\n      this.projection = Object.keys(projection).reduce(function (acc, k) {\n        acc[k] = relative(projection[k]);\n        return acc;\n      }, {});\n      this.depPaths = Object.keys(this.projection).map(function (k) {\n        return _this2.projection[k];\n      });\n    } else {\n      this.projection = projection.map(relative);\n      this.depPaths = this.projection;\n    }\n\n    // Internal state\n    this.state = {\n      killed: false\n    };\n\n    /**\n     * Listener on the tree's `write` event.\n     *\n     * When the tree writes, this listener will check whether the updated paths\n     * are of any use to the monkey and, if so, will update the tree's node\n     * where the monkey sits.\n     */\n    this.writeListener = function (_ref) {\n      var path = _ref.data.path;\n\n      if (_this2.state.killed) return;\n\n      // Is the monkey affected by the current write event?\n      var concerned = (0, _helpers.solveUpdate)([path], _this2.relatedPaths());\n\n      if (concerned) _this2.update();\n    };\n\n    /**\n     * Listener on the tree's `monkey` event.\n     *\n     * When another monkey updates, this listener will check whether the\n     * updated paths are of any use to the monkey and, if so, will update the\n     * tree's node where the monkey sits.\n     */\n    this.recursiveListener = function (_ref2) {\n      var _ref2$data = _ref2.data;\n      var monkey = _ref2$data.monkey;\n      var path = _ref2$data.path;\n\n      if (_this2.state.killed) return;\n\n      // Breaking if this is the same monkey\n      if (_this2 === monkey) return;\n\n      // Is the monkey affected by the current monkey event?\n      var concerned = (0, _helpers.solveUpdate)([path], _this2.relatedPaths(false));\n\n      if (concerned) _this2.update();\n    };\n\n    // Binding listeners\n    this.tree.on('write', this.writeListener);\n    this.tree.on('_monkey', this.recursiveListener);\n\n    // Updating relevant node\n    this.update();\n  }\n\n  /**\n   * Method returning solved paths related to the monkey.\n   *\n   * @param  {boolean} recursive - Should we compute recursive paths?\n   * @return {array}             - An array of related paths.\n   */\n\n  _createClass(Monkey, [{\n    key: 'relatedPaths',\n    value: function relatedPaths() {\n      var _this3 = this;\n\n      var recursive = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];\n\n      var paths = undefined;\n\n      if (this.definition.hasDynamicPaths) paths = this.depPaths.map(function (p) {\n        return (0, _helpers.getIn)(_this3.tree._data, p).solvedPath;\n      });else paths = this.depPaths;\n\n      var isRecursive = recursive && this.depPaths.some(function (p) {\n        return !!_type2['default'].monkeyPath(_this3.tree._monkeys, p);\n      });\n\n      if (!isRecursive) return paths;\n\n      return paths.reduce(function (accumulatedPaths, path) {\n        var monkeyPath = _type2['default'].monkeyPath(_this3.tree._monkeys, path);\n\n        if (!monkeyPath) return accumulatedPaths.concat([path]);\n\n        // Solving recursive path\n        var relatedMonkey = (0, _helpers.getIn)(_this3.tree._monkeys, monkeyPath).data;\n\n        return accumulatedPaths.concat(relatedMonkey.relatedPaths());\n      }, []);\n    }\n\n    /**\n     * Method used to update the tree's internal data with a lazy getter holding\n     * the computed data.\n     *\n     * @return {Monkey} - Returns itself for chaining purposes.\n     */\n  }, {\n    key: 'update',\n    value: function update() {\n      var deps = this.tree.project(this.projection);\n\n      var lazyGetter = (function (tree, def, data) {\n        var cache = null,\n            alreadyComputed = false;\n\n        return function () {\n\n          if (!alreadyComputed) {\n            cache = def.getter.apply(tree, def.type === 'object' ? [data] : data);\n\n            if (tree.options.immutable && def.options.immutable !== false) (0, _helpers.deepFreeze)(cache);\n\n            alreadyComputed = true;\n          }\n\n          return cache;\n        };\n      })(this.tree, this.definition, deps);\n\n      lazyGetter.isLazyGetter = true;\n\n      // Should we write the lazy getter in the tree or solve it right now?\n      if (this.tree.options.lazyMonkeys) {\n        this.tree._data = (0, _update3['default'])(this.tree._data, this.path, {\n          type: 'monkey',\n          value: lazyGetter\n        }, this.tree.options).data;\n      } else {\n        var result = (0, _update3['default'])(this.tree._data, this.path, {\n          type: 'set',\n          value: lazyGetter(),\n          options: {\n            mutableLeaf: !this.definition.options.immutable\n          }\n        }, this.tree.options);\n\n        if ('data' in result) this.tree._data = result.data;\n      }\n\n      // Notifying the monkey's update so we can handle recursivity\n      this.tree.emit('_monkey', { monkey: this, path: this.path });\n\n      return this;\n    }\n\n    /**\n     * Method releasing the monkey from memory.\n     */\n  }, {\n    key: 'release',\n    value: function release() {\n\n      // Unbinding events\n      this.tree.off('write', this.writeListener);\n      this.tree.off('_monkey', this.monkeyListener);\n      this.state.killed = true;\n\n      // Deleting properties\n      // NOTE: not deleting this.definition because some strange things happen\n      // in the _refreshMonkeys method. See #372.\n      delete this.projection;\n      delete this.depPaths;\n      delete this.tree;\n    }\n  }]);\n\n  return Monkey;\n})();\n\nexports.Monkey = Monkey;\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/baobab/dist/monkey.js\n ** module id = 151\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/baobab/dist/monkey.js?");

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Baobab Type Checking\n * =====================\n *\n * Helpers functions used throughout the library to perform some type\n * tests at runtime.\n *\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _monkey = __webpack_require__(151);\n\nvar type = {};\n\n/**\n * Helpers\n * --------\n */\n\n/**\n * Checking whether the given variable is of any of the given types.\n *\n * @todo   Optimize this function by dropping `some`.\n *\n * @param  {mixed} target  - Variable to test.\n * @param  {array} allowed - Array of allowed types.\n * @return {boolean}\n */\nfunction anyOf(target, allowed) {\n  return allowed.some(function (t) {\n    return type[t](target);\n  });\n}\n\n/**\n * Simple types\n * -------------\n */\n\n/**\n * Checking whether the given variable is an array.\n *\n * @param  {mixed} target - Variable to test.\n * @return {boolean}\n */\ntype.array = function (target) {\n  return Array.isArray(target);\n};\n\n/**\n * Checking whether the given variable is an object.\n *\n * @param  {mixed} target - Variable to test.\n * @return {boolean}\n */\ntype.object = function (target) {\n  return target && typeof target === 'object' && !Array.isArray(target) && !(target instanceof Date) && !(target instanceof RegExp) && !(typeof Map === 'function' && target instanceof Map) && !(typeof Set === 'function' && target instanceof Set);\n};\n\n/**\n * Checking whether the given variable is a string.\n *\n * @param  {mixed} target - Variable to test.\n * @return {boolean}\n */\ntype.string = function (target) {\n  return typeof target === 'string';\n};\n\n/**\n * Checking whether the given variable is a number.\n *\n * @param  {mixed} target - Variable to test.\n * @return {boolean}\n */\ntype.number = function (target) {\n  return typeof target === 'number';\n};\n\n/**\n * Checking whether the given variable is a function.\n *\n * @param  {mixed} target - Variable to test.\n * @return {boolean}\n */\ntype['function'] = function (target) {\n  return typeof target === 'function';\n};\n\n/**\n * Checking whether the given variable is a JavaScript primitive.\n *\n * @param  {mixed} target - Variable to test.\n * @return {boolean}\n */\ntype.primitive = function (target) {\n  return target !== Object(target);\n};\n\n/**\n * Complex types\n * --------------\n */\n\n/**\n * Checking whether the given variable is a valid splicer.\n *\n * @param  {mixed} target    - Variable to test.\n * @param  {array} [allowed] - Optional valid types in path.\n * @return {boolean}\n */\ntype.splicer = function (target) {\n  if (!type.array(target) || target.length < 2) return false;\n\n  return anyOf(target[0], ['number', 'function', 'object']) && type.number(target[1]);\n};\n\n/**\n * Checking whether the given variable is a valid cursor path.\n *\n * @param  {mixed} target    - Variable to test.\n * @param  {array} [allowed] - Optional valid types in path.\n * @return {boolean}\n */\n\n// Order is important for performance reasons\nvar ALLOWED_FOR_PATH = ['string', 'number', 'function', 'object'];\n\ntype.path = function (target) {\n  if (!target && target !== 0 && target !== '') return false;\n\n  return [].concat(target).every(function (step) {\n    return anyOf(step, ALLOWED_FOR_PATH);\n  });\n};\n\n/**\n * Checking whether the given path is a dynamic one.\n *\n * @param  {mixed} path - The path to test.\n * @return {boolean}\n */\ntype.dynamicPath = function (path) {\n  return path.some(function (step) {\n    return type['function'](step) || type.object(step);\n  });\n};\n\n/**\n * Retrieve any monkey subpath in the given path or null if the path never comes\n * across computed data.\n *\n * @param  {mixed} data - The data to test.\n * @param  {array} path - The path to test.\n * @return {boolean}\n */\ntype.monkeyPath = function (data, path) {\n  var subpath = [];\n\n  var c = data,\n      i = undefined,\n      l = undefined;\n\n  for (i = 0, l = path.length; i < l; i++) {\n    subpath.push(path[i]);\n\n    if (typeof c !== 'object') return null;\n\n    c = c[path[i]];\n\n    if (c instanceof _monkey.Monkey) return subpath;\n  }\n\n  return null;\n};\n\n/**\n * Check if the given object property is a lazy getter used by a monkey.\n *\n * @param  {mixed}   o           - The target object.\n * @param  {string}  propertyKey - The property to test.\n * @return {boolean}\n */\ntype.lazyGetter = function (o, propertyKey) {\n  var descriptor = Object.getOwnPropertyDescriptor(o, propertyKey);\n\n  return descriptor && descriptor.get && descriptor.get.isLazyGetter === true;\n};\n\n/**\n * Returns the type of the given monkey definition or `null` if invalid.\n *\n * @param  {mixed} definition - The definition to check.\n * @return {string|null}\n */\ntype.monkeyDefinition = function (definition) {\n\n  if (type.object(definition)) {\n    if (!type['function'](definition.get) || definition.cursors && (!type.object(definition.cursors) || !Object.keys(definition.cursors).every(function (k) {\n      return type.path(definition.cursors[k]);\n    }))) return null;\n\n    return 'object';\n  } else if (type.array(definition)) {\n    var offset = 1;\n\n    if (type.object(definition[definition.length - 1])) offset++;\n\n    if (!type['function'](definition[definition.length - offset]) || !definition.slice(0, -offset).every(function (p) {\n      return type.path(p);\n    })) return null;\n\n    return 'array';\n  }\n\n  return null;\n};\n\n/**\n * Checking whether the given watcher definition is valid.\n *\n * @param  {mixed}   definition - The definition to check.\n * @return {boolean}\n */\ntype.watcherMapping = function (definition) {\n  return type.object(definition) && Object.keys(definition).every(function (k) {\n    return type.path(definition[k]);\n  });\n};\n\n/**\n * Checking whether the given string is a valid operation type.\n *\n * @param  {mixed} string - The string to test.\n * @return {boolean}\n */\n\n// Ordered by likeliness\nvar VALID_OPERATIONS = ['set', 'apply', 'push', 'unshift', 'concat', 'pop', 'shift', 'deepMerge', 'merge', 'splice', 'unset'];\n\ntype.operationType = function (string) {\n  return typeof string === 'string' && !! ~VALID_OPERATIONS.indexOf(string);\n};\n\nexports['default'] = type;\nmodule.exports = exports['default'];\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/baobab/dist/type.js\n ** module id = 152\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/baobab/dist/type.js?");

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Baobab Update\n * ==============\n *\n * The tree's update scheme.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports['default'] = update;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\nvar _type = __webpack_require__(152);\n\nvar _type2 = _interopRequireDefault(_type);\n\nvar _helpers = __webpack_require__(154);\n\nfunction err(operation, expectedTarget, path) {\n  return (0, _helpers.makeError)('Baobab.update: cannot apply the \"' + operation + '\" on ' + ('a non ' + expectedTarget + ' (path: /' + path.join('/') + ').'), { path: path });\n}\n\n/**\n * Function aiming at applying a single update operation on the given tree's\n * data.\n *\n * @param  {mixed}  data      - The tree's data.\n * @param  {path}   path      - Path of the update.\n * @param  {object} operation - The operation to apply.\n * @param  {object} [opts]    - Optional options.\n * @return {mixed}            - Both the new tree's data and the updated node.\n */\n\nfunction update(data, path, operation) {\n  var opts = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n  var operationType = operation.type;\n  var value = operation.value;\n  var _operation$options = operation.options;\n  var operationOptions = _operation$options === undefined ? {} : _operation$options;\n\n  // Dummy root, so we can shift and alter the root\n  var dummy = { root: data },\n      dummyPath = ['root'].concat(_toConsumableArray(path)),\n      currentPath = [];\n\n  // Walking the path\n  var p = dummy,\n      i = undefined,\n      l = undefined,\n      s = undefined;\n\n  for (i = 0, l = dummyPath.length; i < l; i++) {\n\n    // Current item's reference is therefore p[s]\n    // The reason why we don't create a variable here for convenience\n    // is because we actually need to mutate the reference.\n    s = dummyPath[i];\n\n    // Updating the path\n    if (i > 0) currentPath.push(s);\n\n    // If we reached the end of the path, we apply the operation\n    if (i === l - 1) {\n\n      /**\n       * Set\n       */\n      if (operationType === 'set') {\n\n        // Purity check\n        if (opts.pure && p[s] === value) return { node: p[s] };\n\n        if (_type2['default'].lazyGetter(p, s)) {\n          Object.defineProperty(p, s, {\n            value: value,\n            enumerable: true,\n            configurable: true\n          });\n        } else if (opts.persistent && !operationOptions.mutableLeaf) {\n          p[s] = (0, _helpers.shallowClone)(value);\n        } else {\n          p[s] = value;\n        }\n      }\n\n      /**\n       * Monkey\n       */\n      else if (operationType === 'monkey') {\n          Object.defineProperty(p, s, {\n            get: value,\n            enumerable: true,\n            configurable: true\n          });\n        }\n\n        /**\n         * Apply\n         */\n        else if (operationType === 'apply') {\n            var result = value(p[s]);\n\n            // Purity check\n            if (opts.pure && p[s] === result) return { node: p[s] };\n\n            if (_type2['default'].lazyGetter(p, s)) {\n              Object.defineProperty(p, s, {\n                value: result,\n                enumerable: true,\n                configurable: true\n              });\n            } else if (opts.persistent) {\n              p[s] = (0, _helpers.shallowClone)(result);\n            } else {\n              p[s] = result;\n            }\n          }\n\n          /**\n           * Push\n           */\n          else if (operationType === 'push') {\n              if (!_type2['default'].array(p[s])) throw err('push', 'array', currentPath);\n\n              if (opts.persistent) p[s] = p[s].concat([value]);else p[s].push(value);\n            }\n\n            /**\n             * Unshift\n             */\n            else if (operationType === 'unshift') {\n                if (!_type2['default'].array(p[s])) throw err('unshift', 'array', currentPath);\n\n                if (opts.persistent) p[s] = [value].concat(p[s]);else p[s].unshift(value);\n              }\n\n              /**\n               * Concat\n               */\n              else if (operationType === 'concat') {\n                  if (!_type2['default'].array(p[s])) throw err('concat', 'array', currentPath);\n\n                  if (opts.persistent) p[s] = p[s].concat(value);else p[s].push.apply(p[s], value);\n                }\n\n                /**\n                 * Splice\n                 */\n                else if (operationType === 'splice') {\n                    if (!_type2['default'].array(p[s])) throw err('splice', 'array', currentPath);\n\n                    if (opts.persistent) p[s] = _helpers.splice.apply(null, [p[s]].concat(value));else p[s].splice.apply(p[s], value);\n                  }\n\n                  /**\n                   * Pop\n                   */\n                  else if (operationType === 'pop') {\n                      if (!_type2['default'].array(p[s])) throw err('pop', 'array', currentPath);\n\n                      if (opts.persistent) p[s] = (0, _helpers.splice)(p[s], -1, 1);else p[s].pop();\n                    }\n\n                    /**\n                     * Shift\n                     */\n                    else if (operationType === 'shift') {\n                        if (!_type2['default'].array(p[s])) throw err('shift', 'array', currentPath);\n\n                        if (opts.persistent) p[s] = (0, _helpers.splice)(p[s], 0, 1);else p[s].shift();\n                      }\n\n                      /**\n                       * Unset\n                       */\n                      else if (operationType === 'unset') {\n                          if (_type2['default'].object(p)) delete p[s];else if (_type2['default'].array(p)) p.splice(s, 1);\n                        }\n\n                        /**\n                         * Merge\n                         */\n                        else if (operationType === 'merge') {\n                            if (!_type2['default'].object(p[s])) throw err('merge', 'object', currentPath);\n\n                            if (opts.persistent) p[s] = (0, _helpers.shallowMerge)({}, p[s], value);else p[s] = (0, _helpers.shallowMerge)(p[s], value);\n                          }\n\n                          /**\n                           * Deep merge\n                           */\n                          else if (operationType === 'deepMerge') {\n                              if (!_type2['default'].object(p[s])) throw err('deepMerge', 'object', currentPath);\n\n                              if (opts.persistent) p[s] = (0, _helpers.deepMerge)({}, p[s], value);else p[s] = (0, _helpers.deepMerge)(p[s], value);\n                            }\n\n      // Deep freezing the resulting value\n      if (opts.immutable && !operationOptions.mutableLeaf) (0, _helpers.deepFreeze)(p);\n\n      break;\n    }\n\n    // If we reached a leaf, we override by setting an empty object\n    else if (_type2['default'].primitive(p[s])) {\n        p[s] = {};\n      }\n\n      // Else, we shift the reference and continue the path\n      else if (opts.persistent) {\n          p[s] = (0, _helpers.shallowClone)(p[s]);\n        }\n\n    // Should we freeze the current step before continuing?\n    if (opts.immutable && l > 0) (0, _helpers.freeze)(p);\n\n    p = p[s];\n  }\n\n  // If we are updating a dynamic node, we need not return the affected node\n  if (_type2['default'].lazyGetter(p, s)) return { data: dummy.root };\n\n  // Returning new data object\n  return { data: dummy.root, node: p[s] };\n}\n\nmodule.exports = exports['default'];\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/baobab/dist/update.js\n ** module id = 153\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/baobab/dist/update.js?");

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(global) {/* eslint eqeqeq: 0 */\n\n/**\n * Baobab Helpers\n * ===============\n *\n * Miscellaneous helper functions.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nexports.arrayFrom = arrayFrom;\nexports.before = before;\nexports.coercePath = coercePath;\nexports.getIn = getIn;\nexports.makeError = makeError;\nexports.solveRelativePath = solveRelativePath;\nexports.solveUpdate = solveUpdate;\nexports.splice = splice;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _monkey = __webpack_require__(151);\n\nvar _type = __webpack_require__(152);\n\nvar _type2 = _interopRequireDefault(_type);\n\n/**\n * Noop function\n */\nvar noop = Function.prototype;\n\n/**\n * Function returning the index of the first element of a list matching the\n * given predicate.\n *\n * @param  {array}     a  - The target array.\n * @param  {function}  fn - The predicate function.\n * @return {mixed}        - The index of the first matching item or -1.\n */\nfunction index(a, fn) {\n  var i = undefined,\n      l = undefined;\n  for (i = 0, l = a.length; i < l; i++) {\n    if (fn(a[i])) return i;\n  }\n  return -1;\n}\n\n/**\n * Efficient slice function used to clone arrays or parts of them.\n *\n * @param  {array} array - The array to slice.\n * @return {array}       - The sliced array.\n */\nfunction slice(array) {\n  var newArray = new Array(array.length);\n\n  var i = undefined,\n      l = undefined;\n\n  for (i = 0, l = array.length; i < l; i++) newArray[i] = array[i];\n\n  return newArray;\n}\n\n/**\n * Archive abstraction\n *\n * @constructor\n * @param {integer} size - Maximum number of records to store.\n */\n\nvar Archive = (function () {\n  function Archive(size) {\n    _classCallCheck(this, Archive);\n\n    this.size = size;\n    this.records = [];\n  }\n\n  /**\n   * Function creating a real array from what should be an array but is not.\n   * I'm looking at you nasty `arguments`...\n   *\n   * @param  {mixed} culprit - The culprit to convert.\n   * @return {array}         - The real array.\n   */\n\n  /**\n   * Method retrieving the records.\n   *\n   * @return {array} - The records.\n   */\n\n  _createClass(Archive, [{\n    key: 'get',\n    value: function get() {\n      return this.records;\n    }\n\n    /**\n     * Method adding a record to the archive\n     *\n     * @param {object}  record - The record to store.\n     * @return {Archive}       - The archive itself for chaining purposes.\n     */\n  }, {\n    key: 'add',\n    value: function add(record) {\n      this.records.unshift(record);\n\n      // If the number of records is exceeded, we truncate the records\n      if (this.records.length > this.size) this.records.length = this.size;\n\n      return this;\n    }\n\n    /**\n     * Method clearing the records.\n     *\n     * @return {Archive} - The archive itself for chaining purposes.\n     */\n  }, {\n    key: 'clear',\n    value: function clear() {\n      this.records = [];\n      return this;\n    }\n\n    /**\n     * Method to go back in time.\n     *\n     * @param {integer} steps - Number of steps we should go back by.\n     * @return {number}       - The last record.\n     */\n  }, {\n    key: 'back',\n    value: function back(steps) {\n      var record = this.records[steps - 1];\n\n      if (record) this.records = this.records.slice(steps);\n      return record;\n    }\n  }]);\n\n  return Archive;\n})();\n\nexports.Archive = Archive;\n\nfunction arrayFrom(culprit) {\n  return slice(culprit);\n}\n\n/**\n * Function decorating one function with another that will be called before the\n * decorated one.\n *\n * @param  {function} decorator - The decorating function.\n * @param  {function} fn        - The function to decorate.\n * @return {function}           - The decorated function.\n */\n\nfunction before(decorator, fn) {\n  return function () {\n    decorator.apply(null, arguments);\n    fn.apply(null, arguments);\n  };\n}\n\n/**\n * Function cloning the given regular expression. Supports `y` and `u` flags\n * already.\n *\n * @param  {RegExp} re - The target regular expression.\n * @return {RegExp}    - The cloned regular expression.\n */\nfunction cloneRegexp(re) {\n  var pattern = re.source;\n\n  var flags = '';\n\n  if (re.global) flags += 'g';\n  if (re.multiline) flags += 'm';\n  if (re.ignoreCase) flags += 'i';\n  if (re.sticky) flags += 'y';\n  if (re.unicode) flags += 'u';\n\n  return new RegExp(pattern, flags);\n}\n\n/**\n * Function cloning the given variable.\n *\n * @todo: implement a faster way to clone an array.\n *\n * @param  {boolean} deep - Should we deep clone the variable.\n * @param  {mixed}   item - The variable to clone\n * @return {mixed}        - The cloned variable.\n */\nfunction cloner(deep, item) {\n  if (!item || typeof item !== 'object' || item instanceof Error || item instanceof _monkey.MonkeyDefinition || item instanceof _monkey.Monkey || 'ArrayBuffer' in global && item instanceof ArrayBuffer) return item;\n\n  // Array\n  if (_type2['default'].array(item)) {\n    if (deep) {\n      var a = [];\n\n      var i = undefined,\n          l = undefined;\n\n      for (i = 0, l = item.length; i < l; i++) a.push(cloner(true, item[i]));\n      return a;\n    }\n\n    return slice(item);\n  }\n\n  // Date\n  if (item instanceof Date) return new Date(item.getTime());\n\n  // RegExp\n  if (item instanceof RegExp) return cloneRegexp(item);\n\n  // Object\n  if (_type2['default'].object(item)) {\n    var o = {};\n\n    var k = undefined;\n\n    // NOTE: could be possible to erase computed properties through `null`.\n    for (k in item) {\n      if (_type2['default'].lazyGetter(item, k)) {\n        Object.defineProperty(o, k, {\n          get: Object.getOwnPropertyDescriptor(item, k).get,\n          enumerable: true,\n          configurable: true\n        });\n      } else if (item.hasOwnProperty(k)) {\n        o[k] = deep ? cloner(true, item[k]) : item[k];\n      }\n    }\n    return o;\n  }\n\n  return item;\n}\n\n/**\n * Exporting shallow and deep cloning functions.\n */\nvar shallowClone = cloner.bind(null, false),\n    deepClone = cloner.bind(null, true);\n\nexports.shallowClone = shallowClone;\nexports.deepClone = deepClone;\n\n/**\n * Coerce the given variable into a full-fledged path.\n *\n * @param  {mixed} target - The variable to coerce.\n * @return {array}        - The array path.\n */\n\nfunction coercePath(target) {\n  if (target || target === 0 || target === '') return target;\n  return [];\n}\n\n/**\n * Function comparing an object's properties to a given descriptive\n * object.\n *\n * @param  {object} object      - The object to compare.\n * @param  {object} description - The description's mapping.\n * @return {boolean}            - Whether the object matches the description.\n */\nfunction compare(object, description) {\n  var ok = true,\n      k = undefined;\n\n  // If we reached here via a recursive call, object may be undefined because\n  // not all items in a collection will have the same deep nesting structure.\n  if (!object) return false;\n\n  for (k in description) {\n    if (_type2['default'].object(description[k])) {\n      ok = ok && compare(object[k], description[k]);\n    } else if (_type2['default'].array(description[k])) {\n      ok = ok && !! ~description[k].indexOf(object[k]);\n    } else {\n      if (object[k] !== description[k]) return false;\n    }\n  }\n\n  return ok;\n}\n\n/**\n * Function freezing the given variable if possible.\n *\n * @param  {boolean} deep - Should we recursively freeze the given objects?\n * @param  {object}  o    - The variable to freeze.\n * @return {object}    - The merged object.\n */\nfunction freezer(deep, o) {\n  if (typeof o !== 'object' || o === null || o instanceof _monkey.Monkey) return;\n\n  Object.freeze(o);\n\n  if (!deep) return;\n\n  if (Array.isArray(o)) {\n\n    // Iterating through the elements\n    var i = undefined,\n        l = undefined;\n\n    for (i = 0, l = o.length; i < l; i++) freezer(true, o[i]);\n  } else {\n    var p = undefined,\n        k = undefined;\n\n    for (k in o) {\n      if (_type2['default'].lazyGetter(o, k)) continue;\n\n      p = o[k];\n\n      if (!p || !o.hasOwnProperty(k) || typeof p !== 'object' || Object.isFrozen(p)) continue;\n\n      freezer(true, p);\n    }\n  }\n}\n\n/**\n * Exporting both `freeze` and `deepFreeze` functions.\n * Note that if the engine does not support `Object.freeze` then this will\n * export noop functions instead.\n */\nvar isFreezeSupported = typeof Object.freeze === 'function';\n\nvar freeze = isFreezeSupported ? freezer.bind(null, false) : noop,\n    deepFreeze = isFreezeSupported ? freezer.bind(null, true) : noop;\n\nexports.freeze = freeze;\nexports.deepFreeze = deepFreeze;\n\n/**\n * Function retrieving nested data within the given object and according to\n * the given path.\n *\n * @todo: work if dynamic path hit objects also.\n * @todo: memoized perfgetters.\n *\n * @param  {object}  object - The object we need to get data from.\n * @param  {array}   path   - The path to follow.\n * @return {object}  result            - The result.\n * @return {mixed}   result.data       - The data at path, or `undefined`.\n * @return {array}   result.solvedPath - The solved path or `null`.\n * @return {boolean} result.exists     - Does the path exists in the tree?\n */\nvar NOT_FOUND_OBJECT = { data: undefined, solvedPath: null, exists: false };\n\nfunction getIn(object, path) {\n  if (!path) return NOT_FOUND_OBJECT;\n\n  var solvedPath = [];\n\n  var exists = true,\n      c = object,\n      idx = undefined,\n      i = undefined,\n      l = undefined;\n\n  for (i = 0, l = path.length; i < l; i++) {\n    if (!c) return {\n      data: undefined,\n      solvedPath: solvedPath.concat(path.slice(i)),\n      exists: false\n    };\n\n    if (typeof path[i] === 'function') {\n      if (!_type2['default'].array(c)) return NOT_FOUND_OBJECT;\n\n      idx = index(c, path[i]);\n      if (! ~idx) return NOT_FOUND_OBJECT;\n\n      solvedPath.push(idx);\n      c = c[idx];\n    } else if (typeof path[i] === 'object') {\n      if (!_type2['default'].array(c)) return NOT_FOUND_OBJECT;\n\n      idx = index(c, function (e) {\n        return compare(e, path[i]);\n      });\n      if (! ~idx) return NOT_FOUND_OBJECT;\n\n      solvedPath.push(idx);\n      c = c[idx];\n    } else {\n      solvedPath.push(path[i]);\n      exists = typeof c === 'object' && path[i] in c;\n      c = c[path[i]];\n    }\n  }\n\n  return { data: c, solvedPath: solvedPath, exists: exists };\n}\n\n/**\n * Little helper returning a JavaScript error carrying some data with it.\n *\n * @param  {string} message - The error message.\n * @param  {object} [data]  - Optional data to assign to the error.\n * @return {Error}          - The created error.\n */\n\nfunction makeError(message, data) {\n  var err = new Error(message);\n\n  for (var k in data) {\n    err[k] = data[k];\n  }return err;\n}\n\n/**\n * Function taking n objects to merge them together.\n * Note 1): the latter object will take precedence over the first one.\n * Note 2): the first object will be mutated to allow for perf scenarios.\n * Note 3): this function will consider monkeys as leaves.\n *\n * @param  {boolean}   deep    - Whether the merge should be deep or not.\n * @param  {...object} objects - Objects to merge.\n * @return {object}            - The merged object.\n */\nfunction merger(deep) {\n  for (var _len = arguments.length, objects = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    objects[_key - 1] = arguments[_key];\n  }\n\n  var o = objects[0];\n\n  var t = undefined,\n      i = undefined,\n      l = undefined,\n      k = undefined;\n\n  for (i = 1, l = objects.length; i < l; i++) {\n    t = objects[i];\n\n    for (k in t) {\n      if (deep && _type2['default'].object(t[k]) && !(t[k] instanceof _monkey.Monkey)) {\n        o[k] = merger(true, o[k] || {}, t[k]);\n      } else {\n        o[k] = t[k];\n      }\n    }\n  }\n\n  return o;\n}\n\n/**\n * Exporting both `shallowMerge` and `deepMerge` functions.\n */\nvar shallowMerge = merger.bind(null, false),\n    deepMerge = merger.bind(null, true);\n\nexports.shallowMerge = shallowMerge;\nexports.deepMerge = deepMerge;\n\n/**\n * Solving a potentially relative path.\n *\n * @param  {array} base - The base path from which to solve the path.\n * @param  {array} to   - The subpath to reach.\n * @param  {array}      - The solved absolute path.\n */\n\nfunction solveRelativePath(base, to) {\n  var solvedPath = [];\n\n  // Coercing to array\n  to = [].concat(to);\n\n  for (var i = 0, l = to.length; i < l; i++) {\n    var step = to[i];\n\n    if (step === '.') {\n      if (!i) solvedPath = base.slice(0);\n    } else if (step === '..') {\n      solvedPath = (!i ? base : solvedPath).slice(0, -1);\n    } else {\n      solvedPath.push(step);\n    }\n  }\n\n  return solvedPath;\n}\n\n/**\n * Function determining whether some paths in the tree were affected by some\n * updates that occurred at the given paths. This helper is mainly used at\n * cursor level to determine whether the cursor is concerned by the updates\n * fired at tree level.\n *\n * NOTES: 1) If performance become an issue, the following threefold loop\n *           can be simplified to a complex twofold one.\n *        2) A regex version could also work but I am not confident it would\n *           be faster.\n *        3) Another solution would be to keep a register of cursors like with\n *           the monkeys and update along this tree.\n *\n * @param  {array} affectedPaths - The paths that were updated.\n * @param  {array} comparedPaths - The paths that we are actually interested in.\n * @return {boolean}             - Is the update relevant to the compared\n *                                 paths?\n */\n\nfunction solveUpdate(affectedPaths, comparedPaths) {\n  var i = undefined,\n      j = undefined,\n      k = undefined,\n      l = undefined,\n      m = undefined,\n      n = undefined,\n      p = undefined,\n      c = undefined,\n      s = undefined;\n\n  // Looping through possible paths\n  for (i = 0, l = affectedPaths.length; i < l; i++) {\n    p = affectedPaths[i];\n\n    if (!p.length) return true;\n\n    // Looping through logged paths\n    for (j = 0, m = comparedPaths.length; j < m; j++) {\n      c = comparedPaths[j];\n\n      if (!c || !c.length) return true;\n\n      // Looping through steps\n      for (k = 0, n = c.length; k < n; k++) {\n        s = c[k];\n\n        // If path is not relevant, we break\n        // NOTE: the '!=' instead of '!==' is required here!\n        if (s != p[k]) break;\n\n        // If we reached last item and we are relevant\n        if (k + 1 === n || k + 1 === p.length) return true;\n      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * Non-mutative version of the splice array method.\n *\n * @param  {array}    array        - The array to splice.\n * @param  {integer}  startIndex   - The start index.\n * @param  {integer}  nb           - Number of elements to remove.\n * @param  {...mixed} elements     - Elements to append after splicing.\n * @return {array}                 - The spliced array.\n */\n\nfunction splice(array, startIndex, nb) {\n  nb = Math.max(0, nb);\n\n  // Solving startIndex\n  if (_type2['default']['function'](startIndex)) startIndex = index(array, startIndex);\n  if (_type2['default'].object(startIndex)) startIndex = index(array, function (e) {\n    return compare(e, startIndex);\n  });\n\n  // Positive index\n\n  for (var _len2 = arguments.length, elements = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n    elements[_key2 - 3] = arguments[_key2];\n  }\n\n  if (startIndex >= 0) return array.slice(0, startIndex).concat(elements).concat(array.slice(startIndex + nb));\n\n  // Negative index\n  return array.slice(0, array.length + startIndex).concat(elements).concat(array.slice(array.length + startIndex + nb));\n}\n\n/**\n * Function returning a unique incremental id each time it is called.\n *\n * @return {integer} - The latest unique id.\n */\nvar uniqid = (function () {\n  var i = 0;\n\n  return function () {\n    return i++;\n  };\n})();\n\nexports.uniqid = uniqid;\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/baobab/dist/helpers.js\n ** module id = 154\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/baobab/dist/helpers.js?");

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Baobab Watchers\n * ================\n *\n * Abstraction used to listen and retrieve data from multiple parts of a\n * Baobab tree at once.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _emmett = __webpack_require__(149);\n\nvar _emmett2 = _interopRequireDefault(_emmett);\n\nvar _cursor = __webpack_require__(150);\n\nvar _cursor2 = _interopRequireDefault(_cursor);\n\nvar _type = __webpack_require__(152);\n\nvar _type2 = _interopRequireDefault(_type);\n\nvar _helpers = __webpack_require__(154);\n\n/**\n * Watcher class.\n *\n * @constructor\n * @param {Baobab} tree     - The watched tree.\n * @param {object} mapping  - A mapping of the paths to watch in the tree.\n */\n\nvar Watcher = (function (_Emitter) {\n  _inherits(Watcher, _Emitter);\n\n  function Watcher(tree, mapping) {\n    var _this = this;\n\n    _classCallCheck(this, Watcher);\n\n    _get(Object.getPrototypeOf(Watcher.prototype), 'constructor', this).call(this);\n\n    // Properties\n    this.tree = tree;\n    this.mapping = null;\n\n    this.state = {\n      killed: false\n    };\n\n    // Initializing\n    this.refresh(mapping);\n\n    // Listening\n    this.handler = function (e) {\n      if (_this.state.killed) return;\n\n      var watchedPaths = _this.getWatchedPaths();\n\n      if ((0, _helpers.solveUpdate)(e.data.paths, watchedPaths)) return _this.emit('update');\n    };\n\n    this.tree.on('update', this.handler);\n  }\n\n  /**\n   * Method used to get the current watched paths.\n   *\n   * @return {array} - The array of watched paths.\n   */\n\n  _createClass(Watcher, [{\n    key: 'getWatchedPaths',\n    value: function getWatchedPaths() {\n      var _this2 = this;\n\n      var rawPaths = Object.keys(this.mapping).map(function (k) {\n        var v = _this2.mapping[k];\n\n        // Watcher mappings can accept a cursor\n        if (v instanceof _cursor2['default']) return v.solvedPath;\n\n        return _this2.mapping[k];\n      });\n\n      return rawPaths.reduce(function (cp, p) {\n\n        // Handling path polymorphisms\n        p = [].concat(p);\n\n        // Dynamic path?\n        if (_type2['default'].dynamicPath(p)) p = (0, _helpers.getIn)(_this2.tree._data, p).solvedPath;\n\n        if (!p) return cp;\n\n        // Facet path?\n        var monkeyPath = _type2['default'].monkeyPath(_this2.tree._monkeys, p);\n\n        if (monkeyPath) return cp.concat((0, _helpers.getIn)(_this2.tree._monkeys, monkeyPath).data.relatedPaths());\n\n        return cp.concat([p]);\n      }, []);\n    }\n\n    /**\n     * Method used to return a map of the watcher's cursors.\n     *\n     * @return {object} - TMap of relevant cursors.\n     */\n  }, {\n    key: 'getCursors',\n    value: function getCursors() {\n      var _this3 = this;\n\n      var cursors = {};\n\n      Object.keys(this.mapping).forEach(function (k) {\n        var path = _this3.mapping[k];\n\n        if (path instanceof _cursor2['default']) cursors[k] = path;else cursors[k] = _this3.tree.select(path);\n      });\n\n      return cursors;\n    }\n\n    /**\n     * Method used to refresh the watcher's mapping.\n     *\n     * @param  {object}  mapping  - The new mapping to apply.\n     * @return {Watcher}          - Itself for chaining purposes.\n     */\n  }, {\n    key: 'refresh',\n    value: function refresh(mapping) {\n\n      if (!_type2['default'].watcherMapping(mapping)) throw (0, _helpers.makeError)('Baobab.watch: invalid mapping.', { mapping: mapping });\n\n      this.mapping = mapping;\n\n      // Creating the get method\n      var projection = {};\n\n      for (var k in mapping) {\n        projection[k] = mapping[k] instanceof _cursor2['default'] ? mapping[k].path : mapping[k];\n      }this.get = this.tree.project.bind(this.tree, projection);\n    }\n\n    /**\n     * Methods releasing the watcher from memory.\n     */\n  }, {\n    key: 'release',\n    value: function release() {\n\n      this.tree.off('update', this.handler);\n      this.state.killed = true;\n      this.kill();\n    }\n  }]);\n\n  return Watcher;\n})(_emmett2['default']);\n\nexports['default'] = Watcher;\nmodule.exports = exports['default'];\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/baobab/dist/watcher.js\n ** module id = 155\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/baobab/dist/watcher.js?");

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	eval("var StateTree = __webpack_require__(157);\n\nvar Model = function (initialState, options) {\n\n  options = options || {};\n\n  var tree = new StateTree(initialState);\n\n  var model = function (controller) {\n\n    controller.on('change', function () {\n      controller.emit('flush', tree.flushChanges());\n    });\n\n    controller.on('seek', function (seek, recording) {\n      recording.initialState.forEach(function (state) {\n        tree.set(state.path, state.value);\n      });\n    });\n\n    return {\n        logModel: function () {\n          return tree.get();\n        },\n        accessors: {\n          get: function (path) {\n            return tree.get(path);\n          },\n          toJSON: function () {\n            return JSON.parse(JSON.stringify(tree.get()));\n          },\n          toJS: function (path) {\n            return tree.get(path);\n          },\n          export: function () {\n            return tree.get();\n          },\n          keys: function (path) {\n            return Object.keys(tree.get(path));\n          },\n          findWhere: function (path, obj) {\n            var keysCount = Object.keys(obj).length;\n            return tree.get(path).filter(function (item) {\n              return Object.keys(item).filter(function (key) {\n                return key in obj && obj[key] === item[key];\n              }).length === keysCount;\n            }).pop();\n          }\n        },\n        mutators: {\n          set: function (path, value) {\n            tree.set(path, value);\n          },\n          import: function (newState) {\n            tree.import(newState);\n          },\n          unset: function (path, keys) {\n            if (keys) {\n              keys.forEach(function (key) {\n                tree.unset(path.concat(key));\n              })\n            } else {\n              tree.unset(path);\n            }\n          },\n          push: function (path, value) {\n            tree.push(path, value);\n          },\n          splice: function () {\n            var args = [].slice.call(arguments);\n            tree.splice.apply(tree, [args.shift()].concat(args));\n          },\n          merge: function (path, value) {\n            tree.merge(path, value);\n          },\n          concat: function () {\n            tree.concat.apply(tree, arguments);\n          },\n          pop: function (path) {\n            tree.pop(path);\n          },\n          shift: function (path) {\n            tree.shift(path);\n          },\n          unshift: function (path, value) {\n            tree.unshift(path, value);\n          }\n        }\n    };\n\n  };\n\n  return model;\n\n};\n\nmodule.exports = Model;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/cerebral-model/index.js\n ** module id = 156\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/cerebral-model/index.js?");

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	eval("// class factories exported as CommonJS module \"default\"\nvar StateTree = __webpack_require__(158).default\n\nmodule.exports = function (initialState) {\n  return new StateTree(initialState)\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/state-tree/index.js\n ** module id = 157\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/state-tree/index.js?");

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar references_1 = __webpack_require__(159);\nvar utils_1 = __webpack_require__(160);\nvar StateTree = (function () {\n    function StateTree(initialState) {\n        this._subscribers = [];\n        this._changes = {};\n        this._state = StateTree.setReferences(initialState, []);\n    }\n    StateTree.prototype._updateChanges = function (host, key) {\n        var _this = this;\n        function update(pathArray) {\n            return function (currentPath, key, index) {\n                if (Array.isArray(key)) {\n                    key = key[0].indexOf(key[1]);\n                    currentPath[key] = index === pathArray.length - 1 ? true : {};\n                }\n                else if (index === pathArray.length - 1 && !currentPath[key]) {\n                    currentPath[key] = true;\n                }\n                else if (index < pathArray.length - 1) {\n                    currentPath[key] = typeof currentPath[key] === 'object' ? currentPath[key] : {};\n                }\n                return currentPath[key];\n            };\n        }\n        host['.referencePaths'].forEach(function (path) {\n            var pathArray = path ? path.concat(key) : [key];\n            pathArray.reduce(update(pathArray), _this._changes);\n        });\n    };\n    StateTree.prototype.get = function (path) {\n        path = path ? typeof path === 'string' ? path.split('.') : path : [];\n        return StateTree.getByPath(path, this._state);\n    };\n    StateTree.prototype.set = function (path, value) {\n        var pathArray = typeof path === 'string' ? path.split('.') : path;\n        var originalPath = pathArray.slice();\n        var key = pathArray.pop();\n        var host = StateTree.getByPath(pathArray, this._state, true);\n        StateTree.cleanReferences(host[key], this._state, originalPath);\n        host[key] = StateTree.setReferences(value, pathArray.concat(key));\n        this._updateChanges(host, key);\n    };\n    StateTree.prototype.push = function (path, value) {\n        var pathArray = typeof path === 'string' ? path.split('.') : path;\n        var key = pathArray.pop();\n        var host = StateTree.getByPath(pathArray, this._state);\n        var length = host[key].push(references_1.setReferences(value, pathArray.concat(key, [[host[key], value]])));\n        this._updateChanges(host[key], String(length - 1));\n    };\n    StateTree.prototype.unshift = function (path, value) {\n        var pathArray = typeof path === 'string' ? path.split('.') : path.slice();\n        var key = pathArray.pop();\n        var host = StateTree.getByPath(pathArray, this._state);\n        var length = host[key].unshift(references_1.setReferences(value, pathArray.concat(key, [[host[key], value]])));\n        this._updateChanges(host[key], String(0));\n    };\n    StateTree.prototype.unset = function (path) {\n        var pathArray = typeof path === 'string' ? path.split('.') : path;\n        var originalPath = pathArray.slice();\n        var key = pathArray.pop();\n        var host = StateTree.getByPath(pathArray, this._state);\n        StateTree.cleanReferences(host[key], this._state, originalPath);\n        delete host[key];\n        this._updateChanges(host, key);\n    };\n    StateTree.prototype.shift = function (path) {\n        var pathArray = typeof path === 'string' ? path.split('.') : path.slice();\n        var originalPath = pathArray.slice();\n        var key = pathArray.pop();\n        var host = StateTree.getByPath(pathArray, this._state);\n        references_1.cleanReferences(host[key][0], this._state, originalPath.concat(0));\n        host[key].shift();\n        this._updateChanges(host[key], String(0));\n    };\n    StateTree.prototype.splice = function () {\n        var args = [].slice.call(arguments);\n        var path = args.shift();\n        var fromIndex = args.shift();\n        var length = args.shift();\n        var pathArray = typeof path === 'string' ? path.split('.') : path;\n        var originalPath = pathArray.slice();\n        var key = pathArray.pop();\n        var host = StateTree.getByPath(pathArray, this._state);\n        // Clear references on existing items and set update path\n        for (var x = fromIndex; x < fromIndex + length; x++) {\n            references_1.cleanReferences(host[key][x], this._state, originalPath.slice().concat(x));\n            this._updateChanges(host[key], String(x));\n        }\n        host[key].splice.apply(host[key], [fromIndex, length].concat(args.map(function (arg) {\n            return references_1.setReferences(arg, pathArray.slice().concat(key, [[host[key], arg]]));\n        })));\n    };\n    StateTree.prototype.pop = function (path) {\n        var pathArray = typeof path === 'string' ? path.split('.') : path.slice();\n        var originalPath = pathArray.slice();\n        var key = pathArray.pop();\n        var host = StateTree.getByPath(pathArray, this._state);\n        var lastIndex = host[key].length - 1;\n        references_1.cleanReferences(host[key][lastIndex], this._state, originalPath.concat(lastIndex));\n        host[key].pop();\n        this._updateChanges(host[key], String(lastIndex));\n    };\n    StateTree.prototype.merge = function () {\n        var _this = this;\n        var path;\n        var value;\n        if (arguments.length === 1) {\n            path = '';\n            value = arguments[0];\n        }\n        else {\n            path = arguments[0];\n            value = arguments[1];\n        }\n        var pathArray = typeof path === 'string' ? path.split('.') : path.slice();\n        var originalPath = pathArray.slice();\n        var key = pathArray.pop();\n        var host = StateTree.getByPath(pathArray, this._state, true);\n        var child = host[key] || host;\n        Object.keys(value).forEach(function (mergeKey) {\n            references_1.cleanReferences(child[mergeKey], _this._state, key ? originalPath.slice().concat(mergeKey) : [mergeKey]);\n            child[mergeKey] = references_1.setReferences(value[mergeKey], key ? pathArray.slice().concat(key, mergeKey) : [mergeKey]);\n            _this._updateChanges(child, mergeKey);\n        });\n    };\n    StateTree.prototype.concat = function () {\n        var args = [].slice.call(arguments);\n        var path = args.shift();\n        var pathArray = typeof path === 'string' ? path.split('.') : path.slice();\n        var key = pathArray.pop();\n        var host = StateTree.getByPath(pathArray, this._state);\n        host[key] = host[key].concat.apply(host[key], args.map(function (arg) {\n            return references_1.setReferences(arg, pathArray.slice().concat(key, [[host[key], arg]]));\n        }));\n        this._updateChanges(host, key);\n    };\n    StateTree.prototype.import = function (value) {\n        var _this = this;\n        StateTree.cleanReferences(this._state, this._state, []);\n        this._state = utils_1.deepmerge(this._state, value);\n        Object.keys(this._state).forEach(function (key) {\n            _this._state[key] = references_1.setReferences(_this._state[key], [key]);\n        });\n    };\n    StateTree.prototype.subscribe = function (cb) {\n        this._subscribers.push(cb);\n    };\n    StateTree.prototype.unsubscribe = function (cb) {\n        this._subscribers.splice(this._subscribers.indexOf(cb), 1);\n    };\n    StateTree.prototype.flushChanges = function () {\n        var flushedChanges = this._changes;\n        this._changes = {};\n        this._subscribers.forEach(function (cb) {\n            cb(flushedChanges);\n        });\n        return flushedChanges;\n    };\n    StateTree.setReferences = references_1.setReferences;\n    StateTree.cleanReferences = references_1.cleanReferences;\n    StateTree.getByPath = utils_1.getByPath;\n    return StateTree;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = StateTree;\n//# sourceMappingURL=stateTree.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/state-tree/lib/stateTree.js\n ** module id = 158\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/state-tree/lib/stateTree.js?");

/***/ },
/* 159 */
/***/ function(module, exports) {

	eval("\"use strict\";\nfunction cleanReferences(rootObj, state, originPath) {\n    if (typeof rootObj !== 'object' && rootObj !== null) {\n        return;\n    }\n    function removeReferences(references, originPath) {\n        references.forEach(function (reference) {\n            var obj = reference.reduce(function (currentPath, key) {\n                if (typeof key === 'string') {\n                    return currentPath[key];\n                }\n                else {\n                    return currentPath[key[0].indexOf(key[1])];\n                }\n            }, state);\n            obj['.referencePaths'] = obj['.referencePaths'].filter(function (currentReference) {\n                return currentReference.map(function (key) {\n                    if (typeof key === 'string' || typeof key === 'number') {\n                        return key;\n                    }\n                    else {\n                        return key[0].indexOf(key[1]);\n                    }\n                }).join('.') !== originPath.join('.'); // Might be slow on large arrays\n            });\n        });\n    }\n    function traverse(obj, currentPath) {\n        if (Array.isArray(obj)) {\n            if (obj['.referencePaths']) {\n                obj.forEach(function (item, index) {\n                    currentPath.push(index);\n                    traverse(item, currentPath);\n                    currentPath.pop();\n                });\n                removeReferences(obj['.referencePaths'], currentPath);\n                if (!obj['.referencePaths'].length) {\n                    delete obj['.referencePaths'];\n                }\n            }\n        }\n        else if (typeof obj === 'object' && obj !== null) {\n            if (obj['.referencePaths']) {\n                Object.keys(obj).forEach(function (key) {\n                    currentPath.push(key);\n                    traverse(obj[key], currentPath);\n                    currentPath.pop();\n                });\n                removeReferences(obj['.referencePaths'], currentPath);\n                if (!obj['.referencePaths'].length) {\n                    delete obj['.referencePaths'];\n                }\n            }\n        }\n    }\n    traverse(rootObj, originPath);\n}\nexports.cleanReferences = cleanReferences;\nfunction setReferences(rootObj, basePath) {\n    function traverse(obj, path) {\n        if (typeof obj === 'function') {\n            throw new Error('You can not pass functions into the state tree. This happens on path: ' + path);\n        }\n        if (Array.isArray(obj)) {\n            Object.defineProperty(obj, '.referencePaths', {\n                writable: true,\n                configurable: true,\n                value: obj['.referencePaths'] ? obj['.referencePaths'].concat([path.slice()]) : [path.slice()]\n            });\n            obj.forEach(function (item, index) {\n                path.push([obj, item]);\n                traverse(item, path);\n                path.pop();\n            });\n            return obj;\n        }\n        else if (typeof obj === 'object' && obj !== null) {\n            Object.defineProperty(obj, '.referencePaths', {\n                writable: true,\n                configurable: true,\n                value: obj['.referencePaths'] ? obj['.referencePaths'].concat([path.slice()]) : [path.slice()]\n            });\n            Object.keys(obj).forEach(function (key) {\n                path.push(key);\n                traverse(obj[key], path);\n                path.pop(key);\n            });\n            return obj;\n        }\n        return obj;\n    }\n    return traverse(rootObj, basePath);\n}\nexports.setReferences = setReferences;\n//# sourceMappingURL=references.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/state-tree/lib/references.js\n ** module id = 159\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/state-tree/lib/references.js?");

/***/ },
/* 160 */
/***/ function(module, exports) {

	eval("\"use strict\";\nfunction getByPath(path, state, forcePath) {\n    var currentPath = state;\n    for (var x = 0; x < path.length; x++) {\n        var key = path[x];\n        if (forcePath && currentPath[key] === undefined) {\n            var newBranch = {};\n            Object.defineProperty(newBranch, '.referencePaths', {\n                writable: true,\n                configurable: true,\n                value: [path.slice().splice(0, x + 1)]\n            });\n            currentPath[key] = newBranch;\n        }\n        if (currentPath[key] === undefined) {\n            return currentPath[key];\n        }\n        currentPath = currentPath[key];\n    }\n    return currentPath;\n}\nexports.getByPath = getByPath;\nfunction deepmerge(target, src) {\n    var array = Array.isArray(src);\n    var dst = array && [] || {};\n    if (array) {\n        target = target || [];\n        dst = src.slice();\n        src.forEach(function (e, i) {\n            if (typeof dst[i] === 'undefined') {\n                dst[i] = e;\n            }\n            else if (typeof e === 'object') {\n                dst[i] = deepmerge(target[i], e);\n            }\n        });\n    }\n    else {\n        if (target && typeof target === 'object') {\n            Object.keys(target).forEach(function (key) {\n                dst[key] = target[key];\n            });\n        }\n        Object.keys(src).forEach(function (key) {\n            if (typeof src[key] !== 'object' || !src[key]) {\n                dst[key] = src[key];\n            }\n            else {\n                if (!target[key]) {\n                    dst[key] = src[key];\n                }\n                else {\n                    dst[key] = deepmerge(target[key], src[key]);\n                }\n            }\n        });\n    }\n    return dst;\n}\nexports.deepmerge = deepmerge;\n//# sourceMappingURL=utils.js.map\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/state-tree/lib/utils.js\n ** module id = 160\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/state-tree/lib/utils.js?");

/***/ },
/* 161 */
/***/ function(module, exports) {

	eval("function ModulesProvider(context, execution, controller) {\n  var modules = controller.getModules()\n  var services = controller.getServices()\n  context.modules = Object.keys(modules).reduce(function (contextModules, key) {\n    var modulePath = key.split('.');\n    var absModulePath = modules[key].path;\n    var module = modulePath.reduce(function (contextModules, pathKey) {\n      contextModules[pathKey] = contextModules[pathKey] || {}\n      return contextModules[pathKey]\n    }, contextModules)\n    module.meta = modules[key].meta\n    module.path = absModulePath;\n    module.state = context.state.select(absModulePath)\n    module.services = absModulePath.reduce(function (services, key) {\n      return services[key] || {}\n    }, services)\n\n    if (\n      execution.options.modulePath &&\n      execution.options.modulePath.join('.') === key) {\n        context.module = module\n      }\n\n    return contextModules\n  }, {})\n\n  return context\n}\n\nmodule.exports = ModulesProvider\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/cerebral-provider-modules/index.js\n ** module id = 161\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/cerebral-provider-modules/index.js?");

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* eslint-env browser*/\nvar SignalStore = __webpack_require__(163)\nvar utils = __webpack_require__(168)\nvar requestAnimationFrame = requestAnimationFrame || function (cb) { setTimeout(cb) }\nvar staticTree = __webpack_require__(137)\n\nmodule.exports = function Devtools () {\n  if (typeof window === 'undefined') { return function () {} }\n  if (typeof window.chrome === 'undefined') { return function () {} }\n\n  return function init (module, controller) {\n    controller.addContextProvider(__webpack_require__(169))\n    controller.addContextProvider(__webpack_require__(170))\n    controller.addContextProvider(__webpack_require__(171))\n    controller.addContextProvider(__webpack_require__(172))\n\n    module.addModules({\n      store: SignalStore()\n    })\n\n    module.addSignals({\n      modelChanged: [\n        function changeModel (arg) {\n          arg.state.set(arg.input.path, arg.input.value)\n        }\n      ]\n    })\n\n    var signalStore = controller.getServices()[module.name].store\n\n    var isInitialized = false\n    var hasInitialPayload = false\n    var disableDebugger = false\n    var APP_ID = String(Date.now())\n    var VERSION = 'v4'\n    var isAwaitingFrame = false\n    var nextSignalInLine = 0\n\n    var hasExecutingSignal = function (signal) {\n      function traverseSignals (signals) {\n        return signals.reduce(function (hasExecutingSignal, signal) {\n          if (hasExecutingSignal || signal.isExecuting) {\n            return true\n          }\n\n          return traverseChain(signal.branches)\n        }, false)\n      }\n\n      function traverseChain (chain) {\n        return chain.reduce(function (hasExecutingSignal, action) {\n          if (hasExecutingSignal) {\n            return true\n          }\n\n          if (Array.isArray(action)) {\n            return traverseChain(action)\n          }\n\n          return traverseAction(action)\n        }, false)\n      }\n\n      function traverseAction (action) {\n        var hasExecutingSignal = false\n        if (action.outputPath) {\n          hasExecutingSignal = traverseChain(action.outputs[action.outputPath])\n        }\n        if (action.signals) {\n          hasExecutingSignal = hasExecutingSignal || traverseSignals(action.signals)\n        }\n        return hasExecutingSignal\n      }\n\n      if (signal.isExecuting) {\n        return true\n      }\n\n      return traverseChain(signal.branches)\n    }\n\n    var getOldestExecutingSignalIndex = function (signals, fromIndex) {\n      for (var x = fromIndex; x < signals.length; x++) {\n        if (hasExecutingSignal(signals[x])) {\n          return x\n        }\n      }\n      return signals.length - 1\n    }\n\n    var update = function (signalType, data, forceUpdate) {\n      if (!forceUpdate && (disableDebugger || !data || !hasInitialPayload)) {\n        return\n      }\n\n      var detail = {\n        type: signalType,\n        app: APP_ID,\n        version: VERSION,\n        data: data\n      }\n\n      var event = new CustomEvent('cerebral.dev.update', {\n        detail: JSON.stringify(detail)\n      })\n      window.dispatchEvent(event)\n    }\n\n    var getInit = function () {\n      var signals = signalStore.getSignals()\n      nextSignalInLine = signals.length ? getOldestExecutingSignalIndex(signals, nextSignalInLine) : 0\n      hasInitialPayload = true\n      return {\n        initialModel: controller.get(),\n        signals: signals,\n        disableDebugger: disableDebugger,\n        isExecutingAsync: signalStore.isExecutingAsync()\n      }\n    }\n\n    var updateSignals = function () {\n      if (isAwaitingFrame) {\n        return\n      }\n\n      isAwaitingFrame = true\n      requestAnimationFrame(function () {\n        var signals = signalStore.getSignals()\n\n        // In case last executed signal is now done\n        update('signals', {\n          signals: signals.slice(nextSignalInLine),\n          isExecutingAsync: signalStore.isExecutingAsync()\n        })\n\n        // Set new last executed signal\n        nextSignalInLine = signals.length ? getOldestExecutingSignalIndex(signals, nextSignalInLine) : 0\n        isAwaitingFrame = false\n      })\n    }\n\n    var updateSettings = function () {\n      update('settings', {\n        disableDebugger: disableDebugger\n      }, true)\n    }\n\n    window.addEventListener('cerebral.dev.components', function (event) {\n      update('components', event.detail, true)\n    })\n\n    window.addEventListener('cerebral.dev.debuggerPing', function () {\n      var signals = []\n\n      if (utils.hasLocalStorage()) {\n        disableDebugger = JSON.parse(localStorage.getItem('cerebral_disable_debugger'))\n      }\n\n      signalStore.setSignals(signals)\n      signalStore.rememberInitial(signalStore.getSignals().length - 1)\n      isInitialized = true\n      var event = new CustomEvent('cerebral.dev.cerebralPong', {\n        detail: JSON.stringify({\n          type: 'init',\n          app: APP_ID,\n          version: VERSION,\n          data: getInit()\n        })\n      })\n      window.dispatchEvent(event)\n    })\n\n    window.addEventListener('cerebral.dev.toggleDisableDebugger', function () {\n      disableDebugger = !disableDebugger\n      updateSettings()\n    })\n\n    window.addEventListener('cerebral.dev.resetStore', function () {\n      signalStore.reset()\n      controller.emit('change')\n      update()\n    })\n\n    window.addEventListener('cerebral.dev.remember', function (event) {\n      signalStore.remember(event.detail)\n    })\n\n    window.addEventListener('cerebral.dev.rewrite', function (event) {\n      var signals = signalStore.getSignals()\n      signals.splice(event.detail + 1, signals.length - 1 - event.detail)\n      signalStore.remember(event.detail)\n    })\n\n    window.addEventListener('cerebral.dev.logPath', function (event) {\n      var name = event.detail.name\n      var value = controller.get(event.detail.path)\n      // toValue instead?\n      console.log('CEREBRAL - ' + name + ':', value.toJS ? value.toJS() : value)\n    })\n\n    window.addEventListener('cerebral.dev.logModel', function (event) {\n      console.log('CEREBRAL - model:', controller.logModel())\n    })\n\n    window.addEventListener('cerebral.dev.changeModel', function (event) {\n      module.getSignals().modelChanged(event.detail)\n    })\n\n    window.addEventListener('unload', function () {\n      signalStore.removeRunningSignals()\n\n      if (utils.hasLocalStorage()) {\n        localStorage.setItem('cerebral_disable_debugger', isInitialized && JSON.stringify(disableDebugger))\n      }\n    })\n\n    document.addEventListener('visibilitychange', function () {\n      if (!document.hidden) {\n        updateSettings()\n      }\n    })\n\n    var services = {\n      update: update,\n      start: function () {\n        console.warn('Cerebral: devtools.start() method is deprecated. Devtools has started automatically.')\n      }\n    }\n\n    module.addServices(services)\n\n    controller.getDevtools = function () {\n      console.warn('Cerebral: controller.getDevtools() method is deprecated. Please upgrade your view package to latest version.')\n      return services\n    }\n\n    function start () {\n      if (window.__CEREBRAL_DEVTOOLS_GLOBAL_HOOK__) {\n        window.__CEREBRAL_DEVTOOLS_GLOBAL_HOOK__.signals = controller.getSignals()\n        window.__CEREBRAL_DEVTOOLS_GLOBAL_HOOK__.staticTree = staticTree\n      }\n\n      var event = new CustomEvent('cerebral.dev.cerebralPing')\n      window.dispatchEvent(event)\n\n      console.assert(controller.listeners('modulesLoaded')[0] === start, 'Cerebral devtools: Please do not place any listeners to `modulesLoaded` event before devtools\\'s one.')\n    }\n\n    var listeners = controller.listeners('modulesLoaded')\n    controller.removeAllListeners('modulesLoaded')\n\n    controller.on('modulesLoaded', start)\n    listeners.forEach(function (listener) {\n      controller.on('modulesLoaded', listener)\n    })\n\n    controller.on('change', updateSignals)\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/cerebral-module-devtools/index.js\n ** module id = 162\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/cerebral-module-devtools/index.js?");

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*\n  SignalStore will keep track of all signals triggered. It keeps an array of signals with\n  actions and mutations related to that signal. It will also track any async signals processing. The SignalStore\n  is able to reset state and travel to a \"specific point in time\" by playing back the signals up to a certain\n  signal.\n*/\nvar uuid = __webpack_require__(164)\n\nmodule.exports = function SignalStore () {\n  return function (module, controller) {\n    var signals = []\n    var isRemembering = false\n    var currentIndex = signals.length - 1\n    var hasRememberedInitial = false\n    var asyncActionsRunning = []\n\n    if (controller.addContextProvider) {\n      controller.addContextProvider(__webpack_require__(166))\n      controller.addContextProvider(__webpack_require__(167))\n    }\n\n    var addAsyncAction = function (action) {\n      asyncActionsRunning.push(action)\n    }\n\n    var removeAsyncAction = function (action) {\n      asyncActionsRunning.splice(asyncActionsRunning.indexOf(action), 1)\n    }\n\n    var addSignal = function (signal, options) {\n      options = options || {}\n\n      if (!isRemembering) {\n        signal.signalStoreRef = uuid.v4()\n\n        if (asyncActionsRunning.length) {\n          var currentAction = asyncActionsRunning[asyncActionsRunning.length - 1]\n          currentAction.signals = currentAction.signals || []\n          currentAction.signals.push(signal)\n        } else {\n          currentIndex++\n          signals.push(signal)\n        }\n      }\n    }\n\n    var services = {\n      // This is used when loading up the app and producing the last known state\n      rememberNow: function () {\n        if (!signals.length) {\n          return\n        }\n\n        currentIndex = signals.length - 1\n        this.remember(currentIndex)\n      },\n\n      // Will reset the SignalStore\n      reset: function () {\n        if (!isRemembering) {\n          signals = []\n\n          currentIndex = -1\n\n          controller.emit('reset')\n        }\n      },\n\n      rememberInitial: function (index) {\n        // Both router and debugger might try to do initial remembering\n        if (hasRememberedInitial) {\n          return\n        }\n\n        hasRememberedInitial = true\n        this.remember(index)\n      },\n\n      remember: function (index) {\n        // Flag that we are remembering\n        isRemembering = true\n        controller.emit('reset')\n\n        // If going back to initial state, just return and update\n        if (index === -1) {\n          currentIndex = index\n          isRemembering = false\n        } else {\n          // Start from beginning\n          currentIndex = -1\n\n          // Go through signals\n          try {\n            for (var x = 0; x <= index; x++) {\n              var signal = signals[x]\n              if (!signal) {\n                break\n              }\n\n              // Trigger signal and then set what has become the current signal\n              var signalMethodPath = signal.name.split('.').reduce(function (signals, key) {\n                return signals[key]\n              }, controller.getSignals())\n              signalMethodPath(signal.payload || signal.input, {\n                branches: signal.branches\n              })\n              currentIndex = x\n            }\n          } catch (e) {\n            console.log(e.stack)\n            console.warn('CEREBRAL - There was an error remembering state, it has been reset')\n            this.reset()\n          }\n        }\n\n        controller.emit('change')\n        isRemembering = false\n      },\n\n      removeRunningSignals: function () {\n        for (var x = 0; x < signals.length; x++) {\n          if (signals[x].isExecuting) {\n            signals.splice(x, 1)\n            x--\n          }\n        }\n      },\n\n      getSignals: function () {\n        return signals\n      },\n\n      setSignals: function (newSignals) {\n        signals = signals.concat(newSignals)\n      },\n\n      isExecutingAsync: function () {\n        return !!asyncActionsRunning.length\n      },\n\n      isRemembering: function () {\n        return isRemembering\n      },\n\n      getCurrentIndex: function () {\n        return currentIndex\n      }\n    }\n\n    module.addServices(services)\n    controller.getStore = function getStore () {\n      console.warn('Cerebral: controller.getStore() method is deprecated.')\n      return services\n    }\n\n    controller.on('signalTrigger', function (event) {\n      var signal = event.signal\n\n      if (!isRemembering && currentIndex !== -1 && currentIndex < signals.length - 1) {\n        signal.preventSignalRun()\n        console.warn('Cerebral - Looking in the past, ignored signal ' + signal.name)\n      }\n    })\n    controller.on('signalStart', function (event) {\n      if (!event.signal.isPrevented) addSignal(event.signal)\n    })\n    controller.on('actionStart', function (event) {\n      var action = event.action\n      if (action.isAsync) addAsyncAction(action)\n    })\n    controller.on('actionEnd', function (event) {\n      var action = event.action\n      if (action.isAsync) removeAsyncAction(action)\n    })\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/cerebral-module-signal-store/index.js\n ** module id = 163\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/cerebral-module-signal-store/index.js?");

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	eval("//     uuid.js\n//\n//     Copyright (c) 2010-2012 Robert Kieffer\n//     MIT License - http://opensource.org/licenses/mit-license.php\n\n// Unique ID creation requires a high quality random # generator.  We feature\n// detect to determine the best RNG source, normalizing to a function that\n// returns 128-bits of randomness, since that's what's usually required\nvar _rng = __webpack_require__(165);\n\n// Maps for number <-> hex string conversion\nvar _byteToHex = [];\nvar _hexToByte = {};\nfor (var i = 0; i < 256; i++) {\n  _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n  _hexToByte[_byteToHex[i]] = i;\n}\n\n// **`parse()` - Parse a UUID into it's component bytes**\nfunction parse(s, buf, offset) {\n  var i = (buf && offset) || 0, ii = 0;\n\n  buf = buf || [];\n  s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {\n    if (ii < 16) { // Don't overflow!\n      buf[i + ii++] = _hexToByte[oct];\n    }\n  });\n\n  // Zero out remaining bytes if string was short\n  while (ii < 16) {\n    buf[i + ii++] = 0;\n  }\n\n  return buf;\n}\n\n// **`unparse()` - Convert UUID byte array (ala parse()) into a string**\nfunction unparse(buf, offset) {\n  var i = offset || 0, bth = _byteToHex;\n  return  bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\n// random #'s we need to init node and clockseq\nvar _seedBytes = _rng();\n\n// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\nvar _nodeId = [\n  _seedBytes[0] | 0x01,\n  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n];\n\n// Per 4.2.2, randomize (14 bit) clockseq\nvar _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n// Previous uuid creation time\nvar _lastMSecs = 0, _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  var node = options.node || _nodeId;\n  for (var n = 0; n < 6; n++) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : unparse(b);\n}\n\n// **`v4()` - Generate random UUID**\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v4(options, buf, offset) {\n  // Deprecated - 'format' argument, as supported in v1.2\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options == 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || _rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ii++) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || unparse(rnds);\n}\n\n// Export public API\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\nuuid.parse = parse;\nuuid.unparse = unparse;\n\nmodule.exports = uuid;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/uuid/uuid.js\n ** module id = 164\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/uuid/uuid.js?");

/***/ },
/* 165 */
/***/ function(module, exports) {

	eval("/* WEBPACK VAR INJECTION */(function(global) {\nvar rng;\n\nif (global.crypto && crypto.getRandomValues) {\n  // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto\n  // Moderately fast, high quality\n  var _rnds8 = new Uint8Array(16);\n  rng = function whatwgRNG() {\n    crypto.getRandomValues(_rnds8);\n    return _rnds8;\n  };\n}\n\nif (!rng) {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var  _rnds = new Array(16);\n  rng = function() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return _rnds;\n  };\n}\n\nmodule.exports = rng;\n\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/uuid/rng-browser.js\n ** module id = 165\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/uuid/rng-browser.js?");

/***/ },
/* 166 */
/***/ function(module, exports) {

	eval("module.exports = function (context, execution) {\n  execution.signal.payload = execution.payload\n  return context\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/cerebral/providers/signalPayloadProvider.js\n ** module id = 166\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/cerebral/providers/signalPayloadProvider.js?");

/***/ },
/* 167 */
/***/ function(module, exports) {

	eval("/*\n  ## Used by Recorder and SignalStore to replay signals\n  Should evaluate how signals are replayed. Sometimes you want\n  to actually run the signals again (recorder)\n*/\n\nfunction wrapMutators (target, mutators, action, rootPath) {\n  return Object.keys(target).reduce(function (target, targetKey) {\n    if (targetKey in mutators) {\n      var originalMutator = target[targetKey]\n      target[targetKey] = function () {\n        var args = [].slice.call(arguments)\n        var path = args.shift()\n        action.mutations.push({\n          datetime: Date.now(),\n          name: targetKey,\n          path: typeof path === 'string' ? rootPath.concat(path.split('.')) : rootPath.concat(path),\n          args: args\n        })\n        originalMutator.apply(null, arguments)\n      }\n    }\n    return target\n  }, target)\n}\n\nmodule.exports = function (context, execution, controller) {\n  var model = controller.getModel()\n  var action = execution.action\n  var originalSelect = context.state.select\n\n  action.mutations = action.mutations || []\n  context.state = wrapMutators(context.state, model.mutators, action, [])\n\n  context.state.select = function (path) {\n    var cursor = originalSelect(path)\n    return wrapMutators(cursor, model.mutators, action, typeof path === 'string' ? path.split('.') : path)\n  }\n\n  return context\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/cerebral/providers/actionMutationsProvider.js\n ** module id = 167\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/cerebral/providers/actionMutationsProvider.js?");

/***/ },
/* 168 */
/***/ function(module, exports) {

	eval("/* WEBPACK VAR INJECTION */(function(global) {module.exports = {\n  hasLocalStorage: function () {\n    return typeof global.localStorage !== 'undefined'\n  },\n  debounce: function debounce (func, wait, immediate) {\n    var timeout\n    return function () {\n      var context = this\n      var args = arguments\n      var later = function () {\n        timeout = null\n        if (!immediate) func.apply(context, args)\n      }\n      var callNow = immediate && !timeout\n      clearTimeout(timeout)\n      timeout = setTimeout(later, wait)\n      if (callNow) func.apply(context, args)\n    }\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/cerebral-module-devtools/utils.js\n ** module id = 168\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/cerebral-module-devtools/utils.js?");

/***/ },
/* 169 */
/***/ function(module, exports) {

	eval("var convertServices = function (action, path, modulesPaths, services) {\n  return Object.keys(services).reduce(function (newservices, key) {\n    path.push(key)\n    if (\n      typeof services[key] === 'function' &&\n      services[key].constructor.name === 'Function' &&\n      !Object.keys(services[key]).length &&\n      (!services[key].prototype || !Object.keys(services[key].prototype).length)\n    ) {\n      var servicePath = path.slice()\n      var method = servicePath.pop()\n      newservices[key] = function () {\n        action.serviceCalls.push({\n          name: servicePath.join('.'),\n          method: method,\n          args: [].slice.call(arguments)\n        })\n        return services[key].apply(this, arguments)\n      }\n    } else if (\n      typeof services[key] === 'object' &&\n      !Array.isArray(services[key]) &&\n      services[key] !== null &&\n      modulesPaths.indexOf(path.join('.')) >= 0\n    ) {\n      newservices[key] = convertServices(action, path, modulesPaths, services[key])\n    } else {\n      newservices[key] = services[key]\n    }\n    path.pop(key)\n    return newservices\n  }, {})\n}\n\nmodule.exports = function (context, execution, controller) {\n  var action = execution.action\n  var modules = controller.getModules()\n  var services = controller.getServices()\n  var path = []\n  action.serviceCalls = action.serviceCalls || []\n  context.services = convertServices(action, path, Object.keys(modules), services)\n\n  return context\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/cerebral-module-devtools/providers/actionServicesCallsProvider.js\n ** module id = 169\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/cerebral-module-devtools/providers/actionServicesCallsProvider.js?");

/***/ },
/* 170 */
/***/ function(module, exports) {

	eval("module.exports = function (context, execution) {\n  var originalOutput = context.output\n  var outputPaths = Object.keys(context.output)\n  var output = function () {\n    var path = typeof arguments[0] === 'string' ? arguments[0] : null\n    var payload = path ? arguments[1] : arguments[0]\n    execution.action.output = payload\n    originalOutput.apply(null, arguments)\n  }\n\n  outputPaths.reduce(function (output, key) {\n    output[key] = function () {\n      execution.action.output = arguments[0] || {}\n      originalOutput[key].apply(null, arguments)\n    }\n    return output\n  }, output)\n\n  context.output = output\n\n  return context\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/cerebral-module-devtools/providers/actionOutputProvider.js\n ** module id = 170\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/cerebral-module-devtools/providers/actionOutputProvider.js?");

/***/ },
/* 171 */
/***/ function(module, exports) {

	eval("module.exports = function (context, execution) {\n  execution.action.input = execution.payload\n  return context\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/cerebral-module-devtools/providers/actionInputProvider.js\n ** module id = 171\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/cerebral-module-devtools/providers/actionInputProvider.js?");

/***/ },
/* 172 */
/***/ function(module, exports) {

	eval("module.exports = function (context, execution) {\n  execution.signal.isRecorded = execution.options.isRecorded\n  execution.signal.isRouted = execution.options.isRouted\n  return context\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/~/cerebral-module-devtools/providers/signalOptionsProvider.js\n ** module id = 172\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/~/cerebral-module-devtools/providers/signalOptionsProvider.js?");

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _keys = __webpack_require__(2);\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nexports.default = getState;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getState(input, controller) {\n\n\tif (!input || typeof input === 'string') return controller.get(input);\n\n\tvar stateMap = input;\n\n\treturn (0, _keys2.default)(stateMap).reduce(function (props, key) {\n\t\tprops[key] = stateMap[key].getDepsMap ? stateMap[key].get(controller.get()) : controller.get(stateMap[key]);\n\t\treturn props;\n\t}, {});\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/src/bit/get-state.js\n ** module id = 173\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/src/bit/get-state.js?");

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _keys = __webpack_require__(2);\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nexports.default = getSignals;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getSignals(input, controller) {\n\n\tif (!input || typeof input === 'string') return controller.getSignals(input);\n\n\tvar signals = controller.getSignals();\n\n\tvar signalsMap = typeof input === 'function' ? input(propsToPass, signals) : input;\n\n\treturn (0, _keys2.default)(signalsMap).reduce(function (props, key) {\n\t\tprops[key] = typeof signalsMap[key] === 'function' ? signalsMap[key] : controller.isServer ? getSignalStub(signalsMap[key]) : controller.getSignals(signalsMap[key]);\n\t\treturn props;\n\t}, {});\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/mixxx/bitbox/bitbox-0.2/src/bit/get-signals.js\n ** module id = 174\n ** module chunks = 1\n **/\n//# sourceURL=webpack:////Users/mixxx/bitbox/bitbox-0.2/src/bit/get-signals.js?");

/***/ }
])
});
;